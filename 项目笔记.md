# Github NextJS REACT项目实战

## 技术点

- nextjs
- react+antd
- 数据库
- 接口代理
- 数据同步
  - 用户登录后,再次刷新页面,不用再次请求接口获取数据再渲染页面
- 数据缓存
  - 第一次点击加载数据, 然后回退, 再次点击, 就不再加载，数据就缓存在页面上
  - 服务端渲染的时候，一开始就进入的页面，也要直接缓存，不希望在页面切换后，再次重新加载，就是请求的链接，直接就是缓存到页面上的，不需要请求服务端的数据，再渲染到页面



## 初始化项目

- ```
  npm init -y
  yarn add react react-dom next @zeit/next-css antd axios koa koa-router koa-session babel-plugin-import ioredis redux react-redux redux-devtools-extension redux-thunk redux-saga babel-plugin-styled-components styled-components
  ```

- 让项目跑起来

1. 新建pages目录, 创建index.jsx

```jsx
export default () => {
    return <div>hello</div>
}
```

2. 修改package.json

```json
"scripts": {
    "dev": "next",
    "build": "next build",
    "start": "next start"
},
```

3. npm run dev启动

4. 集成antd

   > 1. next项目不能直接import 一个css文件  next.config.js中配置
   > 2. 解决前端使用import语法
   > 3. antd的按需加载组件

   next.config.js

   ```js
   const withCSS = require('@zeit/next-css')
   if (typeof require !== 'undefined') {
     require.extensions['css'] = file => {}
   }
   module.exports = withCSS({})
   ```

   .babelrc

   ```json
   {
     "presets": ["next/babel"],
     "plugins": [
       [
         "import",
         {
           "libraryName": "antd"
         }
       ]
     ]
   }
   ```

   _app.js 覆盖next自带的App组件, 进行定制化应用, 全局引入antd样式

   ```js
   import App from 'next/app'
   import 'antd/dist/antd.css'
   export default App;
   ```

   index.jsx中使用antd组件

   ```jsx
   import { Button } from 'antd'
   
   export default () => {
     return <div>
       <Button>hello world</Button>
     </div>
   }
   ```



## 项目布局

1. 整体布局使用antd中的Layout, 在components写整体布局, 然后在_app.js中引入并覆盖next自带的App

components/Layout.jsx

```jsx
// 全局布局
import { Layout, Icon, Input, Avatar } from 'antd'
import { useState, useCallback } from 'react'
const { Header, Content, Footer } = Layout
export default ({ children }) => {
  // 增加组件的状态, 因为涉及到用户的输入,进行查询仓库内容
  const [search, setSearch] = useState('')
  // 处理用户输入修改状态数据
  const handleSearchChange = useCallback((e) => {
    setSearch(e.target.value)
  }, [setSearch])
  // antd中对Input.Search组件中onSearch的回调函数,用户在输入框中输入完成后, 处理用户点击搜索和回车
  const handleOnSearch = useCallback(() => {})
  return (
    <Layout>
      <Header>
        <div className="header-left">
          <div>
            <Icon type="github"></Icon>
          </div>
          <div>
            <Input.Search placeholder="搜索仓库" value={search} onChange={ handleSearchChange } onSearch={ handleOnSearch } ></Input.Search>
          </div>
        </div>
        <div className="header-right">
          <div className="user">
            <Avatar size = {40} icon="user" />
          </div>
        </div>
      </Header>
      <Content>
        { children }
      </Content>
      <Footer>
        Develop by Zhicheng Liu @<a href="mailto:zhicheng.liu@cn.abb.com">Zhicheng.Liu@cn.abb.com</a>
      </Footer>
    </Layout>
  )
}
```

2. layout 引入到_app.js中，并继续写Layout.jsx, 继续完善, header的样式

- 由于antd的Header组件是不会增加到html标签节点上的, 所以要单独在Header内部写个div然后设置样式

```jsx
<Header>
	<div className="header-inner">
	{/* 省略... */}
	</div>
</Header>
// 设置header整体的布局样式
<style jsx>{`
    .header-inner {
        display: flex;
        justify-content: space-between;
    }
    .header-left {
        display: flex;
        justify-content: flex-start;
    }
`}
</style>
{/* 全局样式设置, content内部不够会被挤压的解决样式, 让外层的id和layout的类的height为100% */}
<style jsx global>{`
    #__next, .ant-layout {
    	height: 100%;
    }
`}
</style>
```

- 设置图标GITHUB字体样式和footer的样式

```jsx
// header中 github图标Icon的样式,写在外面是这个style永远不会变, 以后组件渲染不用重新定义对象, 
// 保证了每次header组件中使用的组件github样式是同一个对象, 节省内存
const githubIconStyle = {
  color: 'white',
  fontSize: 40,
  display: 'block',
  paddingTop: 10,
  marginRight: 20,
}
const footerStyle = {
  textAlign: 'center'
}

// 组件return
<div>
    <Icon type="github" style={githubIconStyle}></Icon>
</div>
<Footer style={footerStyle} >...</Footer>
```



## 扩展组件

**cloneElement扩展组件可复用性的高级技巧**

1. 削减代码页面标签的数量
2. 代码整洁
3. components/Container组件

- 业务目标
  - 实现Container组件, 让被它包裹的所有组件都能宽度100%, 左右居中, 并设置最大宽度 Container.jsx

```jsx
const style = {
  width: '100%',
  maxWidth: 600,
  marginLeft: 'auto',
  marginRight: 'auto'
}
export default ({ children }) => {
  return <div style={style}>{children}</div>
}
```

- 问题来了, 我们想修改container中的字体为红色, 如下完全可以满足需求, 即给Container容器组件添加一个div, 然后给div添加className, 但是我们希望把Container当作标签, 传递属性的方式修改Container的样式

```jsx
<Content>
	<Container>
    	<div className={content}>
        	{ children }
        </div>
    </Container>
</Content>
<style jsx>{`
	.content {
		color: red;
	}
`}
</style>

```



- Constainer.jsx

```jsx
import { cloneElement } from 'react'

const style = {
  width: '100%',
  maxWidth: 1200,
  marginLeft: 'auto',
  marginRight: 'auto',
  paddingLeft: 20,
  paddingRight: 20
}

/**
 * 1. Constainer组件接收的是一个jsx的标签, 等同于React.createElement('div) 标签类型, 返回的element类型
 * 2. clone传递进来的element类型的"jsx或者组件", 然后使用Container组件的props覆盖clone的element
 * 3. 扩展节点: 对传入的节点(renderer), 增加props属性(如本例增加style), 来新增或覆盖传递进来的节点, 达到扩展组件或节点的目的
 */
export default ({ children, renderer = <div />}) => {
  console.log(renderer);
  const newElement =  cloneElement(renderer, {
    style: Object.assign({}, renderer.props.style, style),  // 合并style, 将用户自定义的style和本组件设置的style进行合并
    children
  })
  console.log(newElement);
  return newElement;
}

```

- 创建一个测试组件, 组件可以接收的参数props有: color, style, children

```jsx
const MyComp = ({ color, style, children }) => <div style={ color, ...style }>
    { children }
</div>
```

- Layout.jsx中使用Container组件,该传递props就传递, color,

```jsx
<Constainer renderer={<Comp color="red" style={{ fontSize: 40 }}>}>
	{ children } 
</Constainer>
```

- 总结

传入一个组件Comp, 这个组件带有自身样式或者特性, 然后clone这个组件或者jsx, cloneElement, 然后封装组件Container有自定义好的样式或者特性, 然后将Comp中的props和Container中的属性进行对象属性合并

- 调整header中antd自带的样式, 对header-inner的样式div增加Container的样式

```jsx
<Header>
    <Container renderer={<div className="header-inner" />}>
        {/* .... */}
    </Container>
</Header>
```

- header的左右padding为50, 去掉, 踩坑: 样式之间不是以逗号分隔的

```jsx
<style jsx global>
	{`
        #__next, .ant-layout {
            height: 100%;
        }
		// 此处不能加"逗号" , 
        .ant-layout-header {
            padding-left: 0!important;
            padding-right: 0!important;
        }
    `}
</style>
```



## 服务端渲染同步用户信息

1. 在next服务端渲染前, 给ctx.req.session 赋值为ctx.session
2. 然后在redux初始化的地方
3. 服务端渲染,初始状态正确, 刷新之后, 状态数据，前端改变的数据和服务端数据不一致的问题解释
4. 后端server不需要提供一个接口, 然后前端请求接口, 后端返回github用户数据, 最后前端再拿到userInfo, 其实是不需要的, github认证以及获取数据可以在next服务端渲染之前, 把ctx.req.session = ctx.session
5. 赋值之后, 在redux初始化的时候, withRedux.js中, getOrCreateStore函数接收initState, 就可以把这个session设置到全局了
6. 再看store.js, 

- 服务端渲染, 通过react代码通过webpack打包生成的js，会放在.next目录下
- 然后server.js启动服务后, 会动态加载打包之后的js,也就是把打包的js当作Nodejs模块，
- 我们就可以认为，服务端渲染的时候，store.js可以认为是nodejs的模块，`export default store`
- 既然认为是nodejs的模块, store.js代码中导出的store对象就是独一份的, 是共享的
- 也就是它**不会**在每次服务端渲染时, 都会生成一份新的store
- 服务端渲染，store.js在被加载的时候, 已经被生成好了, 服务器在启动之后并不是每次都要重启服务器
- 那么在服务器启动之后, 服务端渲染就都使用同一个store对象
- 这就导致了，状态改变了，是不会进行重置的，默认初始状态是0



## 获取用户信息

代码 server.js中, 所有请求的中间件中, 设置ctx.req.session = ctx.session

> ctx.session其实做了两件事
>
> 通过koa-session这个包对ctx增加了session属性
>
> 通过auth(server)  通过判断路径为/auth进行鉴权时, 满足登录条件的,把userInfo用户信息设置到ctx.session的属性上 如，ctx.session.userInfo

```js
server.use(async (ctx, next) => {
    ctx.req.session = ctx.session
    await handle(ctx.req, ctx.res)	// 服务端返回数据给客户端
    ctx.respond = false
})
```

- 我们希望的是, 在应用初始化的时候, 就把用户的session设置进来

比如, withRedux(MyApp), 在withRedux中, 服务端初始化时(WithRedux.getInitialProps = fn)中，创建store, {getOrCreateStore(服务端初始化用到的参数)}，比如这个参数由user信息。

如何设置的initialState呢? 核心代码是

```js
if (isServer) {
      // 解构的req可能是不存在的,只有在服务端渲染的时候才会存在, 前端切换路由也会执行getInitialProps
      const { req } = ctx.ctx
      const session = req.session
      if (session && session.userInfo) {
    	reduxStore = getOrCreateStore({
          user: session.userInfo
        })
      } else {
 		 reduxStore = getOrCreateStore()       
      }
    
}
```

```js
WithRedux.getInitialProps = async (ctx) => {
    let reduxStore
    if (isServer) {
      // 解构的req可能是不存在的,只有在服务端渲染的时候才会存在, 前端切换路由也会执行getInitialProps
      const { req } = ctx.ctx
      const session = req.session
      // if (session && session.userInfo) {
      if (true) {	// 因为没有登录,测试是否可以设置initialState
        reduxStore = getOrCreateStore({
          user: {
            username: 'sanfeng',
            age: 18
          }
        })
      } else {
        reduxStore = getOrCreateStore()
      }
    } else {
      reduxStore = getOrCreateStore()
    }

  }
  return WithRedux
```

- 点击登录或者右上角的图标进行登录授权

```jsx
<a href={publicRuntimeConfig.OAUTH_URL}>
    <Avatar size={40} icon="user" />
</a>
```

- 然后把登录的userInfo展现到页面上
  - 拿到store中的数据 import { connect } from 'react-redux'
  - 判断是否有用户数据, 有就显示img, 没有就显示默认图标Avatar

```jsx
const mapStateToProps = state => {
    return {
        user: state.user
    }
}
export default connect(mapStateToProps)(MyLayout)
```

```jsx
// 判断组件是否有user, 通过_app.js中的
import App from 'next/app'
import { Provider } from 'react-redux'
import Layout from '../components/Layout'
import withRedux from './store/store'
class MyAPP extends A {
    static async getInitialProps (ctx) {
        const { Component } = ctx
        let pageProps = {}
        if (Component.getInitialProps) {
            pageProps = await Component.getInitialProps(ctx)
        }
        return {
            pageProps
        }
    }
    render () {
        const { Component, pageProps, reduxStore } = this.props
        return (
        	<Provider store={reduxStore}>
            	<Layout>
                	<Component pageProps = {pageProps}/>
                </Layout>
            </Provider>
        )
    }
}
```

```jsx
import {Layout, DropDown, Menu, Tooltip } from 'antd'
import getConfig from 'next/config'
const { publicRuntimeConfig } = getConfig()

const userDropdown = (
	<Menu>
    	<Menu.Item>
        	<a href="javascript:void(0)">注 销</a>
        </Menu.Item>
    </Menu>
)

const MyLayout = ({ children, user }) => {
    return (
        {/* 省略其他内容*/}
        <div className="user">
            {
                user && user.id ? (
                    <Tooltip overlay={userDropdown}>
                        <a href="/">
                            <Avatar size={40} src={user.avatar_url}/>    
                        </a>
                    </Tooltip>
                ) : (
                	<Tooltip title="请点击登录">
                        <a href={publicRuntimeConfig.OAUTH_URL}>
                        	<Avatar size={40} icon="user"/>
                        </a>
                    </Tooltip>
                )
            }
        </div>
    )
}
```



## 注销

1. 鼠标悬停头像图标，出现tooltip，点击注销

2. 始终操作的是store中的user状态数据

3. 注销元素上Menu.Item上绑定一个事件, 然后出发action, 在action中触发ajax请求, 然后修改state，因为user的信息是保存在store中的，一旦页面上注销登录之后

   >1. 服务端清空session
   >2. 页面上这个用户信息也要被清空
   >3. 所以退出登录的整个流程都要围绕着store进行

**代码**



```jsx
const MyLayout = ({ children, user }) => {
    const userDropDown = (
    	<Menu>
        	<Menu.Item>
            	<a href="javascript:void(0)" onClick={handleLogout}>
            </Menu.Item>
        </Menu>
    )
    render () {
        
    }
}
```

```jsx
import { connect } from 'react-redux'
import { logout } from '../store/store'
const MyLayout = ({ children, user, logout }) => {
    const handleLogout = useCallback(
    	() => { logout() },  // 调用actionCreators触发actions
        []
    )
    const userDropDown = (
    	/* ... */
    )
}
const mapStateToProps = state => {
    return {
        user: state.user
    }
}
// 定义action与组件内props的映射关系, 这样MyLayout组件可以通过props(入参)获得,组件内即可引用到
const mapActionToProps = dispatch => {
  return {
    logout: () => dispatch(logout())
  }
}
// 想在MyLayout中使用store中的actionscreators，需要connect把store引入进来
export default connect(mapStateToProps,mapActionToProps)(MyLayout)
```

store.js

```js
// actionCreators: 函数返回一个函数, 参数带上dispatch
import axios from 'axios'

// ACTION-TYPE
const LOGOUT = 'LOGOUT'

// 注销: 发送ajax请求, 
export function logout () {
    return dispatch => {
        axios.post('/logout').then(res => {
            if (res.status === 200) {
				dispatch({
                    LOGOUT
                })
            } else {
                console.log('logout failed: ', res)
            }
    	}).catch(err => console.log("err: ", err))
    }
}

// 发送action之后, 对state进行处理 ---> reducer
const userReducer = (state = userInitialState, action) {
    switch (action.type) {
        case LOGOUT:
            return {}		// 清空userInitialState store中清空用户数据 用户状态的所有属性
        default:
            return state
    }
}
```

以上把所有页面端的逻辑写完了, 因为action要触发axios请求, 请求的服务端接口 axios.post('/logout')还没有处理,需要将server端的session进行清空

---------

auth.js中处理了用户的登录, 也一个中间件或者在同一个server.use中写logout的逻辑即可

```js
server.use(async (ctx, next) => {
    if (ctx.path === 'logout' && ctx.method === 'POST') {
        ctx.session = null
        ctx.body = `logout success`
    } else {
        await next()
    }
})
```



## 登录跳转回原路径

> 我们希望的是, 之前在某个路径页面访问,然后需要点击登录, 登录成功后希望还是原来访问的页面而不是跳转回根路径，在auth.js中登录成功(session设置)，ctx.redirect指向原来的路径

1. 路由中间件处理一个路径prepare_auth,获取原来的路径
2. 在点击登录头像时,记录这个url

### 复杂写法

```js
// 处理登录成功跳转回原来的页面
server.use(async (ctx, next) => {
    if (ctx.path === '/prepare-auth' && ctx.method === 'GET') {
      // 在登录请求之前记录的url
      const { url } = ctx.query
      ctx.session.urlBeforeOAuth = url
      // 比如加上ctx.body = {...},以为如果不加, /prepare-auth?url=/details 这个请求resp就是404
      ctx.body = {}
    } else {
      await next()
    }
})
```

- 然后调用一下接口 /prepare_auth， 在Layout.jsx中点击登录的地方

```jsx
{
    // user通过react-redux的connect获取, 通过MyLayout的props进行传递
    user && user.id ?
        (
        <Dropdown overlay={userDropDown}>
            <a href="/">
                <Avatar size={40} src={user.avatar_url} />
            </a>
        </Dropdown>
    ) : (
        <Tooltip title="点击进行登录">
            <a href={publicRuntimeConfig.OAUTH_URL} onClick={handleGoToOAuth}>
                <Avatar size={40} icon="user" />
            </a>
        </Tooltip>
    )
}
```

```jsx
// 发送接口请求, prepare-auth, 把url传递给后端server的中间件, 然后登录成功后redirect
const handleGoToOAuth = useCallback((e) => {
    // 阻止a标签的默认行为
    e.preventDefault()
    // 这个请求的唯一目的是请求后端接口prepare-auth, 通过query的形式把url传递保存起来,然后端进行跳转redirect,
    // 前端依然去做登录认证的事OAUTH_URL
    axios.get(`/prepare-auth?url=${publicRuntimeConfig.OAUTH_URL}`)
    	.then(resp => {
        if (resp.status === 200) {
            location.href = `${publicRuntimeConfig.OAUTH_URL}`
        } else {
            console.log('login failed ', resp)
        }
    }).catch(err => console.log(err))
}, [])
```



### 简便写法

- 点击登录的a标签的url直接是后端请求的接口路径 /prepare-auth?url=${...}, 其实都是get请求
- 并且也不用写onClick事件去单独再发起axios的get请求
- 请求直接交给a标签的href默认行为处理即可
- 然后接口处理中, 把之前的url记录下来之后, ctx.redirect到github oauth进行认证登录
- 由于在server.js中想获取github的请求地址，如果想通过next/config的getConfig是拿不到的,nextjs是前端的包, 所以需要把配置信息从next.config.js中移动到config.js中



- 在a连接的href中直接写auth.js中的中间件处理登陆前的url的处理逻辑

```jsx
<Tooltip title="点击进行登录">
    <a href={`/prepare-auth?url=${router.asPath}`} >
        <Avatar size={40} icon="user" />
    </a>
</Tooltip>
```

- 中间件处理, 区别是 记录下url之后，后端redirect到github的登录授权请求路径

```js
// 处理登录成功跳转回原来的页面
  server.use(async (ctx, next) => {
    if (ctx.path === '/prepare-auth' && ctx.method === 'GET') {
      // 在登录请求之前记录的url
      const { url } = ctx.query
      ctx.session.urlBeforeOAuth = url
      ctx.redirect(config.OAUTH_URL)
    } else {
      await next()
    }
  })
```

- 因为github的登录需要client_id, GITHUB_OAUTH_URL='https://github.com/login/oauth/authorize'，这些信息之前在next.config.js中设置的, 在server.js后端代码中无法获取next/config，所以需要把之前的在next.config.js中的配置信息放置到config.js中，可以将next.config.js中的相关配置删除

```js
const GITHUB_OAUTH_URL = 'https://github.com/login/oauth/authorize'
const SCOPE = 'user'
const client_id = '26dbc07f67038c430e72'

module.exports = {
  github: {
    client_id,
    client_secret: '627fadc84e8e96ba4819458311557b98c4d6ffe4',
    request_token_url: 'https://github.com/login/oauth/access_token'
  },
  GITHUB_OAUTH_URL,
  OAUTH_URL: `${GITHUB_OAUTH_URL}?client_id=${client_id}&scope=${SCOPE}`
}
```





## 全局页面切换的Loading效果

1. 一个loading组件
2. _app.js中的生命周期方法中, 监听路由的切换的事件，定义函数的处理函数，返回loading组件

- PageLoading.jsx

```jsx
import { Spin } from 'antd'

const pageLoading = () => {
  return (
    <div className="root">
      <Spin />
      <style jsx>
        {`
          .root {
            position: fixed;
            z-index: 100;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(255, 255, 255, 0.5);
          }
        `}
      </style>
    </div>
  )
}

export default pageLoading
```

- _app.jsx中设置显示隐藏的状态, 通过生命周期函数, 通过路由的生命周期, 监听路由的routeChangeStart,routeChangeComplete,routeChangeError事件, 执行对状态的修改, this.state.isLoading,在render函数中, 通过判断isLoading是否为true, 在Layout组件中判断是否加入PageLoading组件

```jsx
class MyApp extends App {
  constructor(props) {
    super(props)
    this.state = {
      isLoading: false
    }
  }

  startLoading = () => {
    this.setState({
      isLoading: true
    })
  }

  stopLoading = () => {
    this.setState({
      isLoading: false
    })
  }

  componentDidMount() {
    Router.events.on('routeChangeStart', this.startLoading)
    Router.events.on('routeChangeComplete', this.stopLoading)
    Router.events.on('routeChangeError', this.stopLoading)
  }
  componentWillUnmount() {
    Router.events.off('routeChangeStart', this.startLoading)
    Router.events.off('routeChangeComplete', this.stopLoading)
    Router.events.off('routeChangeError', this.stopLoading)
  }

  render () {
      return (
      	<Provider store={reduxStore}>
          {
            this.state.isLoading ? <PageLoading /> : null
          }
          <Layout>
            {/* 添加链接用于链接跳转，触发执行生命周期方法，组件生命周期方法会触发路由的生命周期方法，路由开始，路由结束，路由出错等事件，然后绑定两个不同的函数startLoading和stopLoading函数, 函数用于修改isLoading的状态 */}
            <Link href="/">
              <a>Index</a>
            </Link>
            <Link href='/detail'>
              <a>detail</a>
            </Link>
            <Component pageProps={pageProps} />
          </Layout>
        </Provider>
      )
  }
}

```





## style-jsx

这种方式引入的样式在不同组件之间不会相互影响，甚至父子组件之间都不会相互影响

## 避坑

1. 配置文件一定要重启, 即使使用了nodemon, 也要重启

```js
module.exports = withCSS({
  env: {
    customerKey: 'A0001',     // 页面使用process.env.customerKey获取
  },
  publicRuntimeConfig: {
    customerKey: 'A0002'
  }
})
```



## github认证

### 配置文件保存github oauth


