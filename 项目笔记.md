# Github NextJS REACT项目实战

## 技术点

- nextjs
- react+antd
- 数据库
- 接口代理
- 数据同步
  - 用户登录后,再次刷新页面,不用再次请求接口获取数据再渲染页面
- 数据缓存
  - 第一次点击加载数据, 然后回退, 再次点击, 就不再加载，数据就缓存在页面上
  - 服务端渲染的时候，一开始就进入的页面，也要直接缓存，不希望在页面切换后，再次重新加载，就是请求的链接，直接就是缓存到页面上的，不需要请求服务端的数据，再渲染到页面



## 初始化项目

- ```
  npm init -y
  yarn add react react-dom next @zeit/next-css antd axios koa koa-router koa-session babel-plugin-import ioredis redux react-redux redux-devtools-extension redux-thunk redux-saga babel-plugin-styled-components styled-components
  ```

- 让项目跑起来

1. 新建pages目录, 创建index.jsx

```jsx
export default () => {
    return <div>hello</div>
}
```

2. 修改package.json

```json
"scripts": {
    "dev": "next",
    "build": "next build",
    "start": "next start"
},
```

3. npm run dev启动

4. 集成antd

   > 1. next项目不能直接import 一个css文件  next.config.js中配置
   > 2. 解决前端使用import语法
   > 3. antd的按需加载组件

   next.config.js

   ```js
   const withCSS = require('@zeit/next-css')
   if (typeof require !== 'undefined') {
     require.extensions['css'] = file => {}
   }
   module.exports = withCSS({})
   ```

   .babelrc

   ```json
   {
     "presets": ["next/babel"],
     "plugins": [
       [
         "import",
         {
           "libraryName": "antd"
         }
       ]
     ]
   }
   ```

   _app.js 覆盖next自带的App组件, 进行定制化应用, 全局引入antd样式

   ```js
   import App from 'next/app'
   import 'antd/dist/antd.css'
   export default App;
   ```

   index.jsx中使用antd组件

   ```jsx
   import { Button } from 'antd'
   
   export default () => {
     return <div>
       <Button>hello world</Button>
     </div>
   }
   ```



## 项目布局

1. 整体布局使用antd中的Layout, 在components写整体布局, 然后在_app.js中引入并覆盖next自带的App

components/Layout.jsx

```jsx
// 全局布局
import { Layout, Icon, Input, Avatar } from 'antd'
import { useState, useCallback } from 'react'
const { Header, Content, Footer } = Layout
export default ({ children }) => {
  // 增加组件的状态, 因为涉及到用户的输入,进行查询仓库内容
  const [search, setSearch] = useState('')
  // 处理用户输入修改状态数据
  const handleSearchChange = useCallback((e) => {
    setSearch(e.target.value)
  }, [setSearch])
  // antd中对Input.Search组件中onSearch的回调函数,用户在输入框中输入完成后, 处理用户点击搜索和回车
  const handleOnSearch = useCallback(() => {})
  return (
    <Layout>
      <Header>
        <div className="header-left">
          <div>
            <Icon type="github"></Icon>
          </div>
          <div>
            <Input.Search placeholder="搜索仓库" value={search} onChange={ handleSearchChange } onSearch={ handleOnSearch } ></Input.Search>
          </div>
        </div>
        <div className="header-right">
          <div className="user">
            <Avatar size = {40} icon="user" />
          </div>
        </div>
      </Header>
      <Content>
        { children }
      </Content>
      <Footer>
        Develop by Zhicheng Liu @<a href="mailto:zhicheng.liu@cn.abb.com">Zhicheng.Liu@cn.abb.com</a>
      </Footer>
    </Layout>
  )
}
```

2. layout 引入到_app.js中，并继续写Layout.jsx, 继续完善, header的样式

- 由于antd的Header组件是不会增加到html标签节点上的, 所以要单独在Header内部写个div然后设置样式

```jsx
<Header>
	<div className="header-inner">
	{/* 省略... */}
	</div>
</Header>
// 设置header整体的布局样式
<style jsx>{`
    .header-inner {
        display: flex;
        justify-content: space-between;
    }
    .header-left {
        display: flex;
        justify-content: flex-start;
    }
`}
</style>
{/* 全局样式设置, content内部不够会被挤压的解决样式, 让外层的id和layout的类的height为100% */}
<style jsx global>{`
    #__next, .ant-layout {
    	height: 100%;
    }
`}
</style>
```

- 设置图标GITHUB字体样式和footer的样式

```jsx
// header中 github图标Icon的样式,写在外面是这个style永远不会变, 以后组件渲染不用重新定义对象, 
// 保证了每次header组件中使用的组件github样式是同一个对象, 节省内存
const githubIconStyle = {
  color: 'white',
  fontSize: 40,
  display: 'block',
  paddingTop: 10,
  marginRight: 20,
}
const footerStyle = {
  textAlign: 'center'
}

// 组件return
<div>
    <Icon type="github" style={githubIconStyle}></Icon>
</div>
<Footer style={footerStyle} >...</Footer>
```



## 扩展组件

**cloneElement扩展组件可复用性的高级技巧**

1. 削减代码页面标签的数量
2. 代码整洁
3. components/Container组件

- 业务目标
  - 实现Container组件, 让被它包裹的所有组件都能宽度100%, 左右居中, 并设置最大宽度 Container.jsx

```jsx
const style = {
  width: '100%',
  maxWidth: 600,
  marginLeft: 'auto',
  marginRight: 'auto'
}
export default ({ children }) => {
  return <div style={style}>{children}</div>
}
```

- 问题来了, 我们想修改container中的字体为红色, 如下完全可以满足需求, 即给Container容器组件添加一个div, 然后给div添加className, 但是我们希望把Container当作标签, 传递属性的方式修改Container的样式

```jsx
<Content>
	<Container>
    	<div className={content}>
        	{ children }
        </div>
    </Container>
</Content>
<style jsx>{`
	.content {
		color: red;
	}
`}
</style>

```



- Constainer.jsx

```jsx
import { cloneElement } from 'react'

const style = {
  width: '100%',
  maxWidth: 1200,
  marginLeft: 'auto',
  marginRight: 'auto',
  paddingLeft: 20,
  paddingRight: 20
}

/**
 * 1. Constainer组件接收的是一个jsx的标签, 等同于React.createElement('div) 标签类型, 返回的element类型
 * 2. clone传递进来的element类型的"jsx或者组件", 然后使用Container组件的props覆盖clone的element
 * 3. 扩展节点: 对传入的节点(renderer), 增加props属性(如本例增加style), 来新增或覆盖传递进来的节点, 达到扩展组件或节点的目的
 */
export default ({ children, renderer = <div />}) => {
  console.log(renderer);
  const newElement =  cloneElement(renderer, {
    style: Object.assign({}, renderer.props.style, style),  // 合并style, 将用户自定义的style和本组件设置的style进行合并
    children
  })
  console.log(newElement);
  return newElement;
}

```

- 创建一个测试组件, 组件可以接收的参数props有: color, style, children

```jsx
const MyComp = ({ color, style, children }) => <div style={ color, ...style }>
    { children }
</div>
```

- Layout.jsx中使用Container组件,该传递props就传递, color,

```jsx
<Constainer renderer={<Comp color="red" style={{ fontSize: 40 }}>}>
	{ children } 
</Constainer>
```

- 总结

传入一个组件Comp, 这个组件带有自身样式或者特性, 然后clone这个组件或者jsx, cloneElement, 然后封装组件Container有自定义好的样式或者特性, 然后将Comp中的props和Container中的属性进行对象属性合并

- 调整header中antd自带的样式, 对header-inner的样式div增加Container的样式

```jsx
<Header>
    <Container renderer={<div className="header-inner" />}>
        {/* .... */}
    </Container>
</Header>
```

- header的左右padding为50, 去掉, 踩坑: 样式之间不是以逗号分隔的

```jsx
<style jsx global>
	{`
        #__next, .ant-layout {
            height: 100%;
        }
		// 此处不能加"逗号" , 
        .ant-layout-header {
            padding-left: 0!important;
            padding-right: 0!important;
        }
    `}
</style>
```



## 服务端渲染同步用户信息

1. 在next服务端渲染前, 给ctx.req.session 赋值为ctx.session
2. 然后在redux初始化的地方
3. 服务端渲染,初始状态正确, 刷新之后, 状态数据，前端改变的数据和服务端数据不一致的问题解释
4. 后端server不需要提供一个接口, 然后前端请求接口, 后端返回github用户数据, 最后前端再拿到userInfo, 其实是不需要的, github认证以及获取数据可以在next服务端渲染之前, 把ctx.req.session = ctx.session
5. 赋值之后, 在redux初始化的时候, withRedux.js中, getOrCreateStore函数接收initState, 就可以把这个session设置到全局了
6. 再看store.js, 

- 服务端渲染, 通过react代码通过webpack打包生成的js，会放在.next目录下
- 然后server.js启动服务后, 会动态加载打包之后的js,也就是把打包的js当作Nodejs模块，
- 我们就可以认为，服务端渲染的时候，store.js可以认为是nodejs的模块，`export default store`
- 既然认为是nodejs的模块, store.js代码中导出的store对象就是独一份的, 是共享的
- 也就是它**不会**在每次服务端渲染时, 都会生成一份新的store
- 服务端渲染，store.js在被加载的时候, 已经被生成好了, 服务器在启动之后并不是每次都要重启服务器
- 那么在服务器启动之后, 服务端渲染就都使用同一个store对象
- 这就导致了，状态改变了，是不会进行重置的，默认初始状态是0



## 获取用户信息

代码 server.js中, 所有请求的中间件中, 设置ctx.req.session = ctx.session

> ctx.session其实做了两件事
>
> 通过koa-session这个包对ctx增加了session属性
>
> 通过auth(server)  通过判断路径为/auth进行鉴权时, 满足登录条件的,把userInfo用户信息设置到ctx.session的属性上 如，ctx.session.userInfo

```js
server.use(async (ctx, next) => {
    ctx.req.session = ctx.session
    await handle(ctx.req, ctx.res)	// 服务端返回数据给客户端
    ctx.respond = false
})
```

- 我们希望的是, 在应用初始化的时候, 就把用户的session设置进来

比如, withRedux(MyApp), 在withRedux中, 服务端初始化时(WithRedux.getInitialProps = fn)中，创建store, {getOrCreateStore(服务端初始化用到的参数)}，比如这个参数由user信息。

如何设置的initialState呢? 核心代码是

```js
if (isServer) {
      // 解构的req可能是不存在的,只有在服务端渲染的时候才会存在, 前端切换路由也会执行getInitialProps
      const { req } = ctx.ctx
      const session = req.session
      if (session && session.userInfo) {
    	reduxStore = getOrCreateStore({
          user: session.userInfo
        })
      } else {
 		 reduxStore = getOrCreateStore()       
      }
    
}
```

```js
WithRedux.getInitialProps = async (ctx) => {
    let reduxStore
    if (isServer) {
      // 解构的req可能是不存在的,只有在服务端渲染的时候才会存在, 前端切换路由也会执行getInitialProps
      const { req } = ctx.ctx
      const session = req.session
      // if (session && session.userInfo) {
      if (true) {	// 因为没有登录,测试是否可以设置initialState
        reduxStore = getOrCreateStore({
          user: {
            username: 'sanfeng',
            age: 18
          }
        })
      } else {
        reduxStore = getOrCreateStore()
      }
    } else {
      reduxStore = getOrCreateStore()
    }

  }
  return WithRedux
```

- 点击登录或者右上角的图标进行登录授权

```jsx
<a href={publicRuntimeConfig.OAUTH_URL}>
    <Avatar size={40} icon="user" />
</a>
```

- 然后把登录的userInfo展现到页面上
  - 拿到store中的数据 import { connect } from 'react-redux'
  - 判断是否有用户数据, 有就显示img, 没有就显示默认图标Avatar

```jsx
const mapStateToProps = state => {
    return {
        user: state.user
    }
}
export default connect(mapStateToProps)(MyLayout)
```

```jsx
// 判断组件是否有user, 通过_app.js中的
import App from 'next/app'
import { Provider } from 'react-redux'
import Layout from '../components/Layout'
import withRedux from './store/store'
class MyAPP extends A {
    static async getInitialProps (ctx) {
        const { Component } = ctx
        let pageProps = {}
        if (Component.getInitialProps) {
            pageProps = await Component.getInitialProps(ctx)
        }
        return {
            pageProps
        }
    }
    render () {
        const { Component, pageProps, reduxStore } = this.props
        return (
        	<Provider store={reduxStore}>
            	<Layout>
                	<Component pageProps = {pageProps}/>
                </Layout>
            </Provider>
        )
    }
}
```

```jsx
import {Layout, DropDown, Menu, Tooltip } from 'antd'
import getConfig from 'next/config'
const { publicRuntimeConfig } = getConfig()

const userDropdown = (
	<Menu>
    	<Menu.Item>
        	<a href="javascript:void(0)">注 销</a>
        </Menu.Item>
    </Menu>
)

const MyLayout = ({ children, user }) => {
    return (
        {/* 省略其他内容*/}
        <div className="user">
            {
                user && user.id ? (
                    <Tooltip overlay={userDropdown}>
                        <a href="/">
                            <Avatar size={40} src={user.avatar_url}/>    
                        </a>
                    </Tooltip>
                ) : (
                	<Tooltip title="请点击登录">
                        <a href={publicRuntimeConfig.OAUTH_URL}>
                        	<Avatar size={40} icon="user"/>
                        </a>
                    </Tooltip>
                )
            }
        </div>
    )
}
```



## 注销

1. 鼠标悬停头像图标，出现tooltip，点击注销

2. 始终操作的是store中的user状态数据

3. 注销元素上Menu.Item上绑定一个事件, 然后出发action, 在action中触发ajax请求, 然后修改state，因为user的信息是保存在store中的，一旦页面上注销登录之后

   >1. 服务端清空session
   >2. 页面上这个用户信息也要被清空
   >3. 所以退出登录的整个流程都要围绕着store进行

**代码**



```jsx
const MyLayout = ({ children, user }) => {
    const userDropDown = (
    	<Menu>
        	<Menu.Item>
            	<a href="javascript:void(0)" onClick={handleLogout}>
            </Menu.Item>
        </Menu>
    )
    render () {
        
    }
}
```

```jsx
import { connect } from 'react-redux'
import { logout } from '../store/store'
const MyLayout = ({ children, user, logout }) => {
    const handleLogout = useCallback(
    	() => { logout() },  // 调用actionCreators触发actions
        []
    )
    const userDropDown = (
    	/* ... */
    )
}
const mapStateToProps = state => {
    return {
        user: state.user
    }
}
// 定义action与组件内props的映射关系, 这样MyLayout组件可以通过props(入参)获得,组件内即可引用到
const mapActionToProps = dispatch => {
  return {
    logout: () => dispatch(logout())
  }
}
// 想在MyLayout中使用store中的actionscreators，需要connect把store引入进来
export default connect(mapStateToProps,mapActionToProps)(MyLayout)
```

store.js

```js
// actionCreators: 函数返回一个函数, 参数带上dispatch
import axios from 'axios'

// ACTION-TYPE
const LOGOUT = 'LOGOUT'

// 注销: 发送ajax请求, 
export function logout () {
    return dispatch => {
        axios.post('/logout').then(res => {
            if (res.status === 200) {
				dispatch({
                    LOGOUT
                })
            } else {
                console.log('logout failed: ', res)
            }
    	}).catch(err => console.log("err: ", err))
    }
}

// 发送action之后, 对state进行处理 ---> reducer
const userReducer = (state = userInitialState, action) {
    switch (action.type) {
        case LOGOUT:
            return {}		// 清空userInitialState store中清空用户数据 用户状态的所有属性
        default:
            return state
    }
}
```

以上把所有页面端的逻辑写完了, 因为action要触发axios请求, 请求的服务端接口 axios.post('/logout')还没有处理,需要将server端的session进行清空

---------

auth.js中处理了用户的登录, 也一个中间件或者在同一个server.use中写logout的逻辑即可

```js
server.use(async (ctx, next) => {
    if (ctx.path === 'logout' && ctx.method === 'POST') {
        ctx.session = null
        ctx.body = `logout success`
    } else {
        await next()
    }
})
```



## 登录跳转回原路径

> 我们希望的是, 之前在某个路径页面访问,然后需要点击登录, 登录成功后希望还是原来访问的页面而不是跳转回根路径，在auth.js中登录成功(session设置)，ctx.redirect指向原来的路径

1. 路由中间件处理一个路径prepare_auth,获取原来的路径
2. 在点击登录头像时,记录这个url

### 复杂写法

```js
// 处理登录成功跳转回原来的页面
server.use(async (ctx, next) => {
    if (ctx.path === '/prepare-auth' && ctx.method === 'GET') {
      // 在登录请求之前记录的url
      const { url } = ctx.query
      ctx.session.urlBeforeOAuth = url
      // 比如加上ctx.body = {...},以为如果不加, /prepare-auth?url=/details 这个请求resp就是404
      ctx.body = {}
    } else {
      await next()
    }
})
```

- 然后调用一下接口 /prepare_auth， 在Layout.jsx中点击登录的地方

```jsx
{
    // user通过react-redux的connect获取, 通过MyLayout的props进行传递
    user && user.id ?
        (
        <Dropdown overlay={userDropDown}>
            <a href="/">
                <Avatar size={40} src={user.avatar_url} />
            </a>
        </Dropdown>
    ) : (
        <Tooltip title="点击进行登录">
            <a href={publicRuntimeConfig.OAUTH_URL} onClick={handleGoToOAuth}>
                <Avatar size={40} icon="user" />
            </a>
        </Tooltip>
    )
}
```

```jsx
// 发送接口请求, prepare-auth, 把url传递给后端server的中间件, 然后登录成功后redirect
const handleGoToOAuth = useCallback((e) => {
    // 阻止a标签的默认行为
    e.preventDefault()
    // 这个请求的唯一目的是请求后端接口prepare-auth, 通过query的形式把url传递保存起来,然后端进行跳转redirect,
    // 前端依然去做登录认证的事OAUTH_URL
    axios.get(`/prepare-auth?url=${publicRuntimeConfig.OAUTH_URL}`)
    	.then(resp => {
        if (resp.status === 200) {
            location.href = `${publicRuntimeConfig.OAUTH_URL}`
        } else {
            console.log('login failed ', resp)
        }
    }).catch(err => console.log(err))
}, [])
```



### 简便写法

- 点击登录的a标签的url直接是后端请求的接口路径 /prepare-auth?url=${...}, 其实都是get请求
- 并且也不用写onClick事件去单独再发起axios的get请求
- 请求直接交给a标签的href默认行为处理即可
- 然后接口处理中, 把之前的url记录下来之后, ctx.redirect到github oauth进行认证登录
- 由于在server.js中想获取github的请求地址，如果想通过next/config的getConfig是拿不到的,nextjs是前端的包, 所以需要把配置信息从next.config.js中移动到config.js中



- 在a连接的href中直接写auth.js中的中间件处理登陆前的url的处理逻辑

```jsx
<Tooltip title="点击进行登录">
    <a href={`/prepare-auth?url=${router.asPath}`} >
        <Avatar size={40} icon="user" />
    </a>
</Tooltip>
```

- 中间件处理, 区别是 记录下url之后，后端redirect到github的登录授权请求路径

```js
// 处理登录成功跳转回原来的页面
  server.use(async (ctx, next) => {
    if (ctx.path === '/prepare-auth' && ctx.method === 'GET') {
      // 在登录请求之前记录的url
      const { url } = ctx.query
      ctx.session.urlBeforeOAuth = url
      ctx.redirect(config.OAUTH_URL)
    } else {
      await next()
    }
  })
```

- 因为github的登录需要client_id, GITHUB_OAUTH_URL='https://github.com/login/oauth/authorize'，这些信息之前在next.config.js中设置的, 在server.js后端代码中无法获取next/config，所以需要把之前的在next.config.js中的配置信息放置到config.js中，可以将next.config.js中的相关配置删除

```js
const GITHUB_OAUTH_URL = 'https://github.com/login/oauth/authorize'
const SCOPE = 'user'
const client_id = '26dbc07f67038c430e72'

module.exports = {
  github: {
    client_id,
    client_secret: '627fadc84e8e96ba4819458311557b98c4d6ffe4',
    request_token_url: 'https://github.com/login/oauth/access_token'
  },
  GITHUB_OAUTH_URL,
  OAUTH_URL: `${GITHUB_OAUTH_URL}?client_id=${client_id}&scope=${SCOPE}`
}
```





## 全局页面切换的Loading效果

1. 一个loading组件
2. _app.js中的生命周期方法中, 监听路由的切换的事件，定义函数的处理函数，返回loading组件

- PageLoading.jsx

```jsx
import { Spin } from 'antd'

const pageLoading = () => {
  return (
    <div className="root">
      <Spin />
      <style jsx>
        {`
          .root {
            position: fixed;
            z-index: 100;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(255, 255, 255, 0.5);
          }
        `}
      </style>
    </div>
  )
}

export default pageLoading
```

- _app.jsx中设置显示隐藏的状态, 通过生命周期函数, 通过路由的生命周期, 监听路由的routeChangeStart,routeChangeComplete,routeChangeError事件, 执行对状态的修改, this.state.isLoading,在render函数中, 通过判断isLoading是否为true, 在Layout组件中判断是否加入PageLoading组件

```jsx
class MyApp extends App {
  constructor(props) {
    super(props)
    this.state = {
      isLoading: false
    }
  }

  startLoading = () => {
    this.setState({
      isLoading: true
    })
  }

  stopLoading = () => {
    this.setState({
      isLoading: false
    })
  }

  componentDidMount() {
    Router.events.on('routeChangeStart', this.startLoading)
    Router.events.on('routeChangeComplete', this.stopLoading)
    Router.events.on('routeChangeError', this.stopLoading)
  }
  componentWillUnmount() {
    Router.events.off('routeChangeStart', this.startLoading)
    Router.events.off('routeChangeComplete', this.stopLoading)
    Router.events.off('routeChangeError', this.stopLoading)
  }

  render () {
      return (
      	<Provider store={reduxStore}>
          {
            this.state.isLoading ? <PageLoading /> : null
          }
          <Layout>
            {/* 添加链接用于链接跳转，触发执行生命周期方法，组件生命周期方法会触发路由的生命周期方法，路由开始，路由结束，路由出错等事件，然后绑定两个不同的函数startLoading和stopLoading函数, 函数用于修改isLoading的状态 */}
            <Link href="/">
              <a>Index</a>
            </Link>
            <Link href='/detail'>
              <a>detail</a>
            </Link>
            <Component pageProps={pageProps} />
          </Layout>
        </Provider>
      )
  }
}

```



## Github接口代理

> 1. github的接口访问是有限制的, 没有登录的是60次每小时, 所有用户的请求次数汇总才60次, 登录是5000次/小时, 并且是每个用户5000次
>
> 2. 如果在全局中请求github的api接口(_app.js), 完全可以在componentDidMount中发起axios的get请求, 很多github的api请求是必须要带上token进行请求的，否则有些是无法获取用户相关的数据的，比如关注的仓库。最好的方式是，把api的请求发送到我们自己的服务(server.js 或者一个koa的中间件)，然后在我们的服务中代理到github，然后在koa的处理中，再根据用户的状态是否为登录，传入token
>
> 3. 那么为什么不把token返回给前端页面上，然后在前端页面带上这个token，发送axios请求到github上呢?
>
>    1. 因为token是十分敏感的信息，不应该暴露给外网，不应该存储在客户端，存储在客户端在发送请求的时候有可能被黑客拦截，获取token，然后返回一些用户数据被利用
>
>    2. 前端不代理github请求的方式
>
>       `axios.get('https://api.github.com/search/repositories?q=react').then(res => {  	console.log(res) })`
>
>    3. github接口请求代理到本地的后端服务
>
>       `axios.get('/github/search/repositories?q=react').then(...)`



- api.js

```js
const github_base_url = 'https://api.github.com'
const axios = require('axios')

module.exports = server => {
  server.use(async (ctx, next) => {
    const path = ctx.path
    if (path.startsWith('/github/')) {
      const githubAuth = ctx.session.githubAuth
      const githuPath = `${github_base_url}${ctx.url.replace('/github/', '/')}`
      // 获取token
      const token = githubAuth && githubAuth.access_token
      let headers = {}
      // 判断是否有token
      if (token) {
        headers['Authorization'] = `${githubAuth.token_type} ${token}`
      }
      try {
        let result = await axios({
          method: 'GET',
          url: githuPath,
          headers
        })
        if (result.status === 200) {
          ctx.set('Content-Type', 'application/json')
          ctx.body = result.data
        } else {
          ctx.set('Content-Type', 'application/json')
          ctx.body = {
            success: false,
            msg: 'axios status is not 200'
          }
        }
      } catch (error) {
        console.log("error: ", error)
        ctx.set('Content-Type', 'application/json')
        ctx.body = {
          success: false
        }
      }
    } else {
      await next()
    }
  })
}

```

- server.js中引入 并使用中间件

```js
// ...
const api = require('./server/api')
auth(server)
api(server)
```



## 完善整体布局

- ant-layout-content这个css类antd提供的, 是个flex布局, 没有设置height, 如果包裹的元素的高度超过了页面高度, 中间的content就会超出content, 并且超过footer, 测试: 给main下的div设置height为1000px

```css
.ant-layout {
    # height: 100%; # 修改前
    min-height: 100%;
}
```

- ant-layout-content 增加背景

```jsx
.ant-layout-content {
	background: #fff;
}
```

- 增加logo图标点击, 跳转到主页 /

```jsx
import Link from 'next/link'
<Link href="/">
    <Icon type="github" style={githubIconStyle} />
</Link>
```

- 完善搜索功能

1. antd中的 Input.Search中定义的事件 onSearch绑定的函数 handleOnSearch(自定义的) 使用useCallback

```jsx
const MyLayout = ({ children, user, logout, router }) => {
    const [SearchText, setSearchText] = useState('')
    const handleOnSearch = useCallback(
        () => {
        	router.push(`/search?query=${SearchText}`)
    	}, [SearchText])
    
    
    return (
    	<div>
        	<Input.Search 
            	value = { SearchText }
                onChange = { handleSearchTextChange }
                onSearch = { handleOnSearch }
            />
        </div>
    )
}
```

2. pages/search.js

> 1. 在search页面中拿到搜索查询信息, SearchText

```jsx
const Search = ({ router }) => {
    return (
    	<span>{ router.query.query }</span>
    )
}
export default Search;
```

3. 晚上Layout 刷新之后, url依然是查询url，比如 http://localhost:3000/search?query=react 但是查询框为空

```jsx
const MyLayout = ({ children, user, logout, router }) => {
    // router.query && router.query.query 避免报错，
    // 如果router.query不存在直接使用router.query.query就会报错
	const urlQuery = router.query && router.query.query
    const [SearchText, setSearchText] = useState(urlQuery || '')
}
```



## Github接口代理完善

### next请求接口就会发生的问题

> 问题描述
>
> **正常情况下, Index页面的服务端请求**
>
> ```jsx
> Index.getInitialProps = async (ctx) => {
>   const result = await Axios
>     .get('/github/search/repositories?q=react')
>     .then(res => console.log(res))
> 
>   return {
>     data: result.data
>   }
> }
> ```
>
> 刷新页面会出现如下错误
>
> ```
> connect ECONNREFUSED 127.0.0.1:80
> Error: connect ECONNREFUSED 127.0.0.1:80
>     at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1106:14)
> ```
>
> **原因是什么?**
>
> 1. axios在**浏览器环境下**发送请求, 请求地址会自动加上网站的域名，也就是http://localhost:3000，然后再加上axios请求的url，那么完整的请求url是: http://localhost:3000/github/search/repositories?q=react
> 2. axios在服务端渲染进行执行, 是没有浏览器的域名的一个场景的, axios在服务端自动增加的就是http://127.0.0.1/github/search/repositories?q=react, 而且也没有加端口号，就是80端口，所以这个服务端的请求发送到了本地的80端口，本地也没有启动80，实际启动的是3000，并且这个请求地址也不是我们期望的请求地址
>
> **如何解决?**
>
> 1. 客户端和服务端的请求要单独分开进行处理, 也就是同构前后端的axios的请求
>
> 2. 然后在组件调用getInitialProps的时候, 无论是客户端调用还是服务端渲染, 统一调用(/lib/api.js)处理后的对外敞开的接口request({}, req, res), 





- 每个页面（组件）的getInitialProps的执行

1. 客户端每个页面跳转时会执行
2. 服务端渲染时,也会执行组件的getInitialProps

- 页面跳转处于**浏览器环境**，服务端渲染执行，处于**nodejs环境**, 

- 服务端发起axios请求时, url请求地址就不会有浏览器才有的domain，

  - 如果服务端请求的是

  ```js
  axios.get('/github/search/repositories?q=react')
  ```

  - nodejs会直接请求的是, 域名就是自己的本地, 端口是80

  ```js
  axios.get('http://localhost/github/search/repositories?q=react')
  ```

- 提取一个公共的api接口, 用来判断是否为服务端渲染 /lib/api.js

### 1. 同构客户端与服务端请求

- 封装一个api.js，用户处理getInitialProps中涉及到的客户端调用还是服务端调用
  - 服务端请求: 从session中拿到token,拼接headers, 以及github的完整的url
  - 客户端请求: 只处理url, 因为请求发送给koa后端中间件, koa对请求接口前缀为/github/进行拦截, 然后处理前端发送的url为github标准的url( 替换 /github/为/), 然后发送请求

#### lib/api.js同构请求

```js
/**
 * 主要用于处理每个组件中的getInitialProps请求接口的函数, 也就是这个文件既要在客户端也要在服务端执行
 * 我们不能使用export语法,nodejs还不支持export
 */
const axios = require('axios')

const github_base_url = 'https://api.github.com'

// 请求github的数据
/**
 * 
 * @param {*} method 
 * @param {*} url 
 * @param {*} data 
 * @param {*} headers 
 */
async function requestGithub (method, url, data, headers) {
  return await axios({
    method,
    url: `${github_base_url}${url}`,    // 拼接github请求的真正的url, 带上域名
    data,
    headers
  })
}

const isServer = typeof window === 'undefined'

/**
 * 这个函数就要区别 客户端请求 还是 服务端请求 自动添加域名的处理
 * 服务端渲染添加本地80端口的域名 http://127.0.0.1/github/...
 * 客户端添加网站域名 http://localhost:3000/github/...
 * @param {} 传递给axios的配置参数, 也就是请求参数 
 * @param {*} req 
 * @param {*} res 
 */
async function request ({ method = 'GET', url, data = {} }, req, res) {
  if (!url) {
    throw Error('url must provide')
  }
  if (isServer) {
    // 如果是服务端渲染, 直接创建请求，请求github的数据
    // 1. 从session中获取access_token
    // 2. 把token拼接到headers上发起请求
    const session = req.session
    const githubAuth = session.githubAuth || {}
    let headers = {}
    if (githubAuth.access_token) {
      headers['Authorization'] = `${githubAuth.token_type} ${githubAuth.access_token}`
    }
    console.log('服务端渲染调用...')
    return await requestGithub(method, url, data, headers)
  } else {
    // 客户端请求, 需要加上/github的开发者约定的前缀, 以便koa中间件代理github请求时, 后端可以对这类特殊请求进行处理
    // 此处为什么不用传递headers? 因为headers是请求到api地址之后,从session里拿到token,然后拼接组合成headers
    console.log('客户端调用...')
    return await axios({
      method,
      url: `/github${url}`,
      data
    })
  }
}

module.exports = {
  request,
  requestGithub
}
```

#### server/api.js处理客户端请求

```js
const { requestGithub } = require('../lib/api')
// koa的中间件服务, 用于处理客户端发起的axios请求
// 从session中获取token, 拼接headers, 发送到github请求数据
module.exports = server => {
  server.use(async (ctx, next) => {
    const path = ctx.path
    const method = ctx.method
    if (path.startsWith('/github/')) {
      // 处理headers
      const session = ctx.session
      const githubAuth = session && session.githubAuth
      const headers = {}
      if (githubAuth && githubAuth.access_token) {
        headers['Authorization'] = `${githubAuth.token_type} ${githubAuth.access_token}`
      }
      // github实际的api可能是 /search/repositoies?q=react, koa做一次代理, 就要给添加一个标志标明是接口请求
      // 所以加上github, 但是实际向github发请求时, 要先将自定义的前缀去掉,ctx.url.replace('/github/', '/')
      // 这样github开放的api接口才是可以请求的
      const result = await requestGithub(
        method,
        ctx.url.replace('/github/', '/'),   
        {},
        headers
      )
      // 把github返回给自己的server原封不动的返回给客户端 status data
      ctx.status = result.status
      ctx.body = result.data
    } else {
      await next()
    }
  })
}

```

#### Index.jsx调用

- 初始化服务端渲染调用getInitialProps
- 页面跳转客户端调用getInitialProps

```jsx
Index.getInitialProps = async ({ ctx }) => {
  // const result = await Axios
  //   .get('/github/search/repositories?q=react')
  //   .then(res => console.log(res))
  // 组件中只需要用request, 因为这个函数已经处理了是客户端还是服务端发起的请求
  const result = await api.request(
    {
      url: '/search/repositories?q=react'
    }, 
    // 只会在服务端渲染的时候才会使用req, 从req中拿到session
    ctx.req, 
    ctx.res
  )
  return {
    data: result.data
  }
}

```

### 2. 处理post请求

```
yarn add koa-better-body
```

server.js

```js
const body = require('koa-better-body')

// 中间件将post请求的数据挂载到ctx.request.fields上
app.prepare().then(() => {
    server.use(body({
        uploadDir: path.resolve(__dirname, './static/upload')
      }))
    }
)

// server/api.js
const result = await requestGithub(
    method,
    ctx.url.replace('/github/', '/'),   
    ctx.request.fields || {},
    headers
)
```

客户端组件模拟一个post请求

index.jsx

```jsx
import { useEffect } from 'react'
import axios from 'axios'
const Index = () => {
    useEffect(() => {
        axios.post('/github/test', { username: 'sanfeng'})
    })
    return (
    	<div>
        	index
        </div>
    )
}
```



## 联调首页数据请求

### 1. 服务端请求数据

- index.jsx中服务端渲染请求github的数据

> 入坑: pages下的组件, getInitialProps方法的return值都可以被当前组件通过props获取到
>
> const { userRepos, userStarredRepos } = this.props
>
> 因为在_app.js中, 对所有Component组件(即所有pages下的每个js文件)的getInitialProps静态方法做了处理，其中, static 的方法返回的pageProps, 传递给Compnent要进行结构{...pageProps},而不是pageProps={pageProps}
>
> ```jsx
> import App from 'next/app'
> import { Provider } from 'react-redux'
> import withRedux from '../lib/withRedux'
> class MyApp extends App {
>     static async getInitialProps (ctx) {
>         const { Component } = ctx;
>         let pageProps = {}
>         if (Component.getInitialProps) {
>             pageProps = await Component.getInitialProps(ctx)
>         }
>         return {
>            pageProps 
>         }
>     }
>     render () {
>         const { Component, pageProps, reduxStore } = this.props
>         return (
>         	<>
>             	<Provider store = { reduxStore }>
>                 	<Layout>
>                 		<Component { ...pageProps } />
>                 	</Layout>
>             	</Provider>
>             </>
>         )
>     }
> }
> export default withRedux(MyApp)
> ```
>
> 

```jsx
const api = require('../lib/api')
const Index = ({userRepos, userStarredRepos}) => {
    return <div>Index</div>
}
Index.getInitialProps = async ({ ctx }) => {
    const userRepos = await api.request({
        url: '/user/repos'
    }, ctx.req, ctx.res)
    const userStarredRepos = await api.request({
        url: '/user/starred'
    }, ctx.req, ctx.res)
    return {
        userRepos: userRepos.data,
        userStarredRepos: userStarredRepos.data
    }
}
export default Index
```



### 2. 退出登录刷新页面401错误

因为已经退出登录, 刷新页面, 首页就是401，未授权，直接报错，未登录状态就无法获取到user相关的信息了

1. 我们可以通过ctx.req.session来判断用户的状态, 是否有user, 或者user.id, 但是这个只能在服务端可以，客户端是不行的，因为客户端在页面切换的时候, ctx上是没有req，res的，这两个对象是nodejs环境的，不存在浏览器的环境下

2. 我们可以使用store中保存的用户信息

   1. 在withRedux.js中, 把store保存到了ctx上

   ```js
   WithRedux.getInitialProps = async (ctx) => {
       let reduxStore
       if (isServer) {
         // 解构的req可能是不存在的,只有在服务端渲染的时候才会存在, 前端切换路由也会执行getInitialProps
         const { req } = ctx.ctx
         const session = req.session
         if (session && session.userInfo) {
           reduxStore = getOrCreateStore({
             user: session.userInfo
           })
         } else {
           reduxStore = getOrCreateStore()
         }
       } else {
         reduxStore = getOrCreateStore()
       }
       // 重点在这里重点在这里重点在这里重点在这里重点在这里重点在这里
       ctx.reduxStore = reduxStore
       // 重点在这里重点在这里重点在这里重点在这里重点在这里重点在这里
       let appProps = {}
       if (typeof Comp.getInitialProps === 'function') {
         appProps = await Comp.getInitialProps(ctx)
       }
       return {
         ...appProps,
         initialReduxState: reduxStore.getState()
       }
     }
   ```

   2. index.jsx

   ```jsx
   Index.getInitialProps = async ({ ctx, reduxStore }) => {
     const user = reduxStore.getState().user
     if (!user || !user.id) {
       return {
         isLogin: false
       }
     }
     // ....
   }
   ```

   3. 但是如果如果点击退出登录之后, 页面依然没有通过判断isLogin来重新渲染页面，没有显示"亲，您还没有登录"

   ```jsx
   function Index({ userRepos, userStarredRepos, isLogin }) {
     // 不能使用传入的isLogin, 要使用store中的, store中的数据发生变化, 会触发组件的重新渲染
     if (!isLogin) {
       return <div className="root">
         <p>亲，您还没有登录</p>
         <Button type="primary" href={config.OAUTH_URL} >点击登录</Button>
         <style jsx>
           {`
             .root {
               height: 400px;
               display: flex;
               flex-direction: column;
               justify-content: center;
               align-items: center;
             }
           `}
         </style>
       </div>
     }
     return <div>Index</div>
   }
   Index.getInitialProps = async ({ ctx, reduxStore }) => {
     const user = reduxStore.getState().user
     if (!user || !user.id) {
       return {
         isLogin: false
       }
     }
     return {
       isLogin: true, //
       userRepos: userRepos.data,
       userStarredRepos: userStarredRepos.data,
     }
   }
   ```

   4. 这是因为getInitialProps存在的局限性，**这个函数在页面进入的瞬间会被调用**，但是登出的操作只是改变了store的状态，并**没有重新刷新页面**，**也没有从别的页面跳转进来**, 所以没有再次调用getInitialProps, 也就不会返回isLogin的最新状态false, 点击登录后, 用户状态是未登录,因为getInitialProps没有执行, isLogin还是true, 所以"亲，您还没有登录"就无法显示了
   5. 如何解决? 使用connect连接store中的状态
   
   ```jsx
   Index.getInitialProps = async ({ ctx, reduxStore }) => {
     const user = reduxStore.getState().user
     if (!user || !user.id) {
       return {
         isLogin: false
       }
     }
     return {
       isLogin: true, //
       userRepos: userRepos.data,
       userStarredRepos: userStarredRepos.data,
     }
   }
   const mapState = state => {
       return {
           user: state.user
       }
   }
   export default connect(mapState)(Index)
   ```
   
   

## Repo组件展示基本组件内容

- 通过Index中的服务端渲染getInitialProps请求数据, return { userRepos: result.data }, 组件通过props获取
- userRepos是数组,直接userRepos.map(repo => <Repo repo={repo}>) 遍历结果数据
- 仓库更新时间格式处理moment

### 抽离组件Repo.js

```jsx
import Link from 'next/link'
import { Icon } from 'antd'
import moment from 'moment'

function getLicense (license) {
  return license ? `${license.spdx_id} license` : ''
}
function getLastUpdated (time) {
  return moment(time).fromNow()
}

export default ({ repo }) => {
  return (
    <div className="root">
      <div className="basic-info">
        <h3 className="repo-title">
          <Link href={`/detail?owner=${repo.owner.login}&name=${repo.name}`}>
            <a>{repo.full_name}</a>
          </Link>
        </h3>
        <p className="repo-desc">{repo.description}</p>
        <p className="other-info">
          {
            // other-info中, 如果没有license没有, span在页面上会多出一个空格,需要进行判断
            repo.license ? <span className="license">{getLicense(repo.license)}</span> 
                : null
          }
          <span className="last-updated">{getLastUpdated(repo.updated_at)}</span>
          <span className="open-issues">{repo.open_issues_count} open issues</span>
        </p>
      </div>
      <div className="lang-star">
        <span className="lang">{repo.language}</span>
        <span className="stars">
          { repo.stargazers_count } <Icon type="star" theme="filled"/>
        </span>
      </div>
      <style jsx>
      {`
        .root {
          display: flex;
          justify-content: space-between;
        }
        .other-info > span + span {
          margin-left: 10px;
        }
        .root + .root {
          border-top: 1px solid #eee;
          padding-top: 20px;
        }
        .repo-title {
          font-size: 20px;
        }
        .lang-star {
          display: flex;
        }
        .lang-star > span {
          width: 120px;
          text-align: right;
        }
        .repo-desc {
          width: 400px;
        }
      `}
      </style>
    </div>
  )
}
```



### flex布局知识点复习

- 给父容器添加flex布局

```css
.box {
    # 给父容器添加flex布局
    display: flex;
    # 容器的主轴对齐
    justify-content: center | flex-start | flex-end | space-between | space-around;
    # 副轴(交叉轴)对齐方式
    align-items: flex-start | flex-end | center | baseline | stretch;
}
```

- 容器中的item的属性

```css

```



## Tabs切换不同主题的repos

在index.jsx中, 设置不同的Tabs, 自己的repos和你关注的repos

```jsx
<div className="user-repos">
	<Tabs defaultActivityKey = "1">
        <Tabs.TabPane tab="你的仓库" key="1">
        	{ userRepos.map(repo => (<Repo repo = { repo }/>))}
        </Tabs.TabPane>
        <Tabs.TabPane tab="你关注的仓库" key="2">
        	{ userStarredRepos.map(repo => (<Repo repo = { repo } />))}
        </Tabs.TabPane>
    </Tabs>
</div>
```

- 存在的问题

  - 当点击的不是默认的repo, 比如key=2的repo, 然后再访问detail页面, 然后再跳转回Index后
    - 回到Index显示的是默认的repo，key=1的信息, 我们希望是返回key=2的你关注的仓库
    - 数据会重新加载 (缓存数据, 非redux的方式, 因为redux是保存公共全局性的数据,保存多个页面的数据)

- 如何解决以上两个问题

  - 把两个tab的属性作为url的query参数保存起来
    - 使用路由 `import { withRouter } from 'next/router'`
    - export default connect(...)(wtihRouter(Index)), 包裹Index, 让组件有router对象
    - 通过router的query拿到key。`const tabKey = router.query.tabKey || '1'`
    - 然后让这个tabKey作为Tab中的activeKey, `<Tabs activeKey={tabKey}></Tabs>`
    - 然后处理Tabs的onChange事件,然后把当前激活的key保存在router的query上

  ```jsx
  const tabKey = router.query.key || '1'
  const handleTabChange = (selectKey) => {
      // 将当前的Tab的key设置到路由上, 点击某个tab, 就会路由设置为http://localhost:3000/?query=1,2,3...
      // 路由是history的, 当你访问/detail之后再回退时, url的路径就是http://localhost:3000/?query=2
      // 此时访问的是Index, 由detail跳转回Index, 所以程序从上向下执行, 就会获取tabKey
      Router.push(`/?key=${selectKey}`)
    }
  
  <Tabs activeKey={tabKey} onChange={ handleTabChange } >
      <Tabs.TabPane tab="你的仓库" key="1">
          {userRepos.map(repo => (
              <Repo repo={repo} />
          ))}
      </Tabs.TabPane>
      <Tabs.TabPane tab="你关注的仓库" key="2">
          {userStarredRepos.map(repo => (
              <Repo repo = {repo} />
          ))}
      </Tabs.TabPane>
  </Tabs>
  ```



## 使用缓存数据

### 1. 使用公共变量缓存数据

**整体思路**

> 1. 在组件模块外定义cacheUserRepos
>
> 2. 服务端渲染时, 请求接口api.request(...), 将结果userRepos.data返回,以便组件Index通过props可以访问
>
> 3. 在组件的前端渲染中, 缓存props中的userRepos到公共变量中cacheUserRepos
> 4. 当页面切换或者重新向后端发起请求时, 调用getInitialProps时, 要优先判断公共变量cacheUserReops是否存在值, 如果存在直接返回缓存的数据给userRepos



> 当使用Tab切换不同的数据的时候, 每一次切换tab, 都会重新请求一次数据，而正常情况下，"我的仓库"和"我关注的仓库"不是经常变化的。其实, 我们在第一次获取页面数据的时候, 是可以将数据进行复用的
>
> 1. 使用一种非redux的实现方式，自己实现基本原理 (逐步细说问题)



```js
// 全局模块中定义缓存的数据变量
let cachedUserRepos, cachedUserStarredRepos

// 请求接口前, 看看是否有缓存数据, 如果有就直接使用缓存, 没有才请求数据
if (cachedUserRepos && cachedUserStarredRepos) {
    return {
        userRepos: cachedUserRepos,
        userStarredRepos: cachedUserStarredRepos
    }
}

// 在获取完数据之后把数据赋值给定义的缓存数据
// 在组件的getInitialProps中获取数据
const userRepos = await api.request({
    url: '/user/repos',
}, ctx.req, ctx.res)
const userStarredRepos = await api.request({
    url: '/user/starred'
}, ctx.req, ctx.res)
// 向后端请求完数据, 把数据存储在缓存中(保存到一个变量中),然后判断这个变量是否为空, 为空就请求数据, 不为空就直接使用之前请求的数据
cachedUserRepos = userRepos.data;
cachedUserStarredRepos = userStarredRepos.data


```

- 问题bug

> 如果使用无痕浏览的方式, 切换另一个github账号登录, 数据还是原来的仓库信息
>
> 因为服务端渲染, index.jsx模块加载了一次, 数据就初始化了, cachedUserRepos等两个变量是全局变量, 数据就不会改变了. 需要把这两个变量移动一下位置，然后判断一下是否为服务端渲染的情况, 如果是服务端端渲染, 就跳过缓存

- 最终的代码

```js
import { useEffect } from 'react'
import Router, { withRouter } from 'next/router'
import { connect } from 'react-redux'

let cachedUserRepos, cachedUserStarredRepos
const isServer = typeof window === 'undefined'

function Index ({ userRepos, userStarredRepos, router, user }) {
    // 这种写法,当组件第一次被mount的时候被调用,后续再mount就不会调用了
    // 而Index页面一直处于两种仓库的切换，应该不两个参数传递给useEffect,
    // 当两个参数发生变化的时候重新设置cache
    useEffect(() => {
        if (!isServer) {
            cachedUserRepos = userRepos
            cachedUserStarredRepos = userStarredRepos
        }
    }, [])
}

Index.getInitialProps = async ({ ctx, reduxStore }) => {
    // ...
    if (cachedUserRepos && cachedUserStarredRepos) {
        return {
            userRepos: cachedUserRepos,
            userStarredRepos: cachedUserStarredRepos
        }
    }
    // 如果没有缓存就直接请求数据
    const userRepos = await api.request({
        url: '/user/repos',
    }, ctx.req, ctx.res)
    const userStarredRepos = await api.request({
        url: '/user/starred'
    }, ctx.req, ctx.res)
    
    return {
        isLogin: true,
        userRepos: userRepos.data,
        userStarredRepos: userStarredRepos.data
    }
}
const mapStateToProps = state => {
    return {
        user: state.user
    }
}
export default withRouter(connect(mapStateToProps)(Index))
```



### 2. 使用lru-cache的缓存策略

> 上面是没有使用缓存策略的, 即缓存数据一直没有变化, 如果初始请求的数据发生了变化, 上面的解决方案将无法实现数据的更新同步
>
> 可以使用maxAge, 把数据缓存加上一个期限 lru-cache

```jsx
import LRU from 'lru-cache'

const cache = new LRU({
    maxAge: 1000 * 60 * 60	// 缓存时长1小时
})
// 在之前将数据缓存到公共变量的地方使用LRU包的cache.set(key, value)的方式进行缓存,然后get获取
const isServer = typeof window === 'undefined'
function Index ({ userRepos, userStarredRepos, router, user }) {
    userEffect(() => {
        if (!isServer) {
            if (userRepos) {
                cache.set('userRepos', userRepos)
            }
            if (userStarredRepos) {
                cache.set('userStarredRepos', userStarredRepos)
            }
        }
    }, [userRepos, userStarredRepos])
    // 把上面两个参数当作依赖, 当两个参数发生了变化, 比如使用了lru-cache之后, 10s之后清空缓存,userRepos, userStarredRepos就是null了, 此时会触发依赖变化重新调用useEffect的函数参数，就会重新设置缓存
}

Index.getInitialProps = async ({ ctx, reduxStore }) => {
 	// 如果缓存中有数据, 直接把缓存数据返回给组件的props   
    if (cache.get('userRepos') && cache.get('userStarredRepos')) {
        return {
            userRepos: cache.get('userRepos'),
            userStarredRepos: cache.get('userStarredRepos')
        }
    }
    // 否则没有缓存就直接请求后端接口数据
    // 1. 列出所有自己创建的仓库
    const userRepos = await api.request({
        url: '/user/repos',
    }, ctx.req, ctx.res)
    // 2. 列出自己关注的接口 (列出当前登录用户所关注的仓库 starred)
    const userStarredRepos = await api.request({
        url: '/user/starred'
    }, ctx.req, ctx.res)
}
```

> LRU使用的场景就是用户频繁使用的，但是不经常修改的数据, 当过了一定的时间之后重新请求数据, 以便数据发生了变更

## 搜索页面

### 1. 版本1

- 从路由中获取数据，把数据渲染到页面中

> 关注的search条件有哪些, 把这些参数放到url,这样可以在浏览器中保存记录, 通过前进后退跳转不同的搜索条件
>
> 1. sort: 排序方式
> 2. order: 排序顺序
> 3. lang: 仓库的项目开发主语言
> 4. page:分页页面
> 5. query

- 首先从Layout.jsx中的查询框的绑定事件开始

```jsx
<Input.Search
     value={SearchText}
     placeholder="input Search text"
     onChange={handleSearchTextChange}
     onSearch={handleOnSearch}
/>

// 搜索框查询事件, 查询结果, 路由跳转到search页面进行展示, 增加search.js
const handleOnSearch = useCallback(
    () => {
        router.push(`/search?query=${SearchText}`)
    }, [SearchText]
)
```

- 拼接路由进行跳转到search页面, 然后调用search页面或组件的getInitialProps函数获取url的查询参数

```js
const MyLayout = ({ router  }) => { // 省略其他参数 如children, user, logout
  const urlQuery = router.query && router.query.query
  const [SearchText, setSearchText] = useState(urlQuery || '')
  const handleSearchTextChange = useCallback(
    e => setSearchText(e.target.value),
    [setSearchText]
  )
  const handleOnSearch = useCallback(
    () => {
        router.push(`/search?query=${SearchText}`)
    }, [SearchText]
  )
}
```

- search组件初始化或者url变更时, 调用getInitialProps进行查询结果的初始化

```jsx
// 根据上面的MyLayout的handleOnSearch的Router.push, 解构出url的query
Search.getInitialProps = ({ ctx }) => {
    // const { query } = ctx.query // 解构出必须的, 因为你必须输入检索词
    // 第一次只是输入了检索词, 肯定只有query, 没有lang,sort等
    const { query, lang, sort, order, page } = ctx.query
    if (!query) {
        return {
            repos: {
                total_count: 0
            }
        }
    }
    // 拼接url
    // ?q=react+language:javascript&sort=stars&order=desc&page=2
    let querystring = `?q=${query}`
    if (lang) querystring += `+language:${lang}`
    if (sort) querystring += `&sort=${sort}&order=${order || 'desc'}`
    if (page) querystring += `&page=${page}`
    const result = await api.request({
        url: `/search/repositories${querystring}`
    }, ctx.req, ctx.res)
    return {
        repos: result.data
    }
}


```



- 页面左侧的搜索条件列表数据

```js
/**
 * 搜索条件，选择了语言, 然后再选择是获得的star最多或者最少,或者获得Fork最多或最少来进行筛选数据
 */
const LANGUAGE = ['javascript', 'HTML', 'CSS', 'Typescript']
const SORT_TYPES = [
  {
    name: 'Best Match' // 默认条件
  },
  {
    name: 'Most Stars',
    value: 'stars',
    order: 'desc'
  },
  {
    name: 'Fewest Stars',
    value: 'stars',
    order: 'asc'
  },
  {
    name: 'Most Forks',
    value: 'forks',
    order: 'desc'
  },
  {
    name: 'Fewest Forks',
    value: 'forks',
    order: 'asc'
  }
]
```

- 根据获取url的query参数, 解构出查询的参数的选项的值, 来拼接querystring

```js
const { lang, sort, order, query } = router.query
```

- 页面结构: 左侧列表, 列表循环每一项查询条件, **点击每一项**, 路由跳转拼接url

```jsx
const { lang, sort, order, query } = router.query
return (
	<div className="root">
    	<Row gutter={20}>
        	<Col span={6}>
            	<List 
                	bordered
                    header={<span className="list-header">语言</span>}
                    style={{ marginBottom: 20 }}
                    dataSource = { LANGUAGE }
                    renderItem = { item => {
                        const selected = item === lang
                        return (
                        	<List.Item style={ selected ? selectedItemStyle : null}>
                            	<a onClick={ () => handleLanguageChange(item) }>
                                    { item }
                                </a>
                            </List.Item>
                        )
                    }}
                />
                <List 
                	bordered
                    header={<span className="list-header">排序</span>}
                    style = {{ marginBottom: 20}}
                    dataSource = { SORT_TYPES }
                    renderItem = { item => {
                        const selected = false
                        if (item.name === 'Best Match' && !sort) {
                            selected = true
                        } else if (item.sort === sort && item.order === order) {
                            selected = true
                        }
                        return (
                        	<List.Item style={ selected ? selectedItemStyle : null}>
                            	<a onClick={ () => { handleSortChange(item)}}>
                                	{ item.name }
                                </a>
                            </List.Item>
                        )
                    }}
                />
            </Col>
        </Row>
    </div>
)
```

- 增加样式, 点击之后列表左侧增加样式

```js
const selectedItemStyle = {
  borderLeft: '2px solid #e36209',
  fontWeight: 100
}
```

- 增加a链接的点击事件, 进行路由跳转, 然后调用上面的Search.getInitialProps, 然后里面解构ctx.query, 拼接github查询的url api

```jsx
import Router from 'next/router'

const { lang, sort, order, query } = router.query
// 语言筛选
const handleLanguageChange = language => {
    Router.push({
        pathname: '/search',
        query: {
            query,
            lang: language,
            sort,
            order
        }
    })
}

const handleSortChange = sort => {
    Router.push({
        pathname: '/search',
        query: {
            query,
            lang,
            sort: sort.value,
            order: sort.order
        }
    })
}
```

### 2. 版本2 优化

1. 路由跳转的代码是十分相似的(handleLanguageChange, handleSortChange), 合并成一个方法 doSearch

```js
// 1. 先整合两个方法，在组件内写
const doSearch = (config) => {
    Router.push({
        pathname: '/search',
        query: config
    })
}
// 2. 再思考,组件内的函数使用useCallback, 但是发现, 这个函数不依赖Search组件内的任何state或props
const doSearch = useCallback(config => {
    Router.push({
        pathname: '/search',
        query: config
    })
}, [])

// 这个方法是个纯粹的方法, 不依赖组件的任何state和props, 所以要提炼出组件外
const doSearch = (config) => {
    Router.push({
        pathname: '/search',
        query: config
    })
}
const Search = ({ router, repos }) => {
    // ...
   return (
        <div className="root">
          <Row gutter={20}>
            <Col span={6}>
              <List
                bordered
                header={<span className="list-header">语言</span>}
                style={{ marginBottom: 20 }}
                dataSource={LANGUAGE}
                renderItem={item => {
                  const selected = item === lang
                  return (<List.Item style={selected ? selectedItemStyle : null}>
                    <a onClick={() => doSearch({
                      query, lang: item, sort, order
                    })}>{item}</a>
                  </List.Item>
                  )
                }}
              />
            </Col>
          </Row>
        </div>
	)
}

// 那么上面这个config从哪里来的呢? 从页面中传递的, 选择点击"语言"的，或者"排序"的, 如下直接传递
<a onClick={() => doSearch({
    query, lang: item, sort, order
})}>{item}</a>

```

2. 合并之后的doSearch, 在把doSearch传递给a标签的onClick，依然要重新声明一个匿名方法的

   onClick={ () => doSearch({query, lang: item, sort, order}) }，每次声明都是一个新的方法，仍然会导致a标签的重新渲染，那么这个a标签的作用是什么? 就是根据url的参数query, lang...以及item这个参数sort,order进行跳转, 那么我们就可以抽象出一个组件来 FilterLink

```jsx
const FilterLink = ({ name, query, lang, sort, order }) => {
    const doSearch = () => {
        Router.push({
            pathname: '/search',
            query: {
                query,
                lang,
                sort,
                order
            }
        })
    }
    return <a onClick={ doSearch }>{ name }</a>
}
```

 

```jsx
// 把之前的a标签替换为FilterLink
<List
    bordered
    header={<span className="list-header">语言</span>}
    style={{ marginBottom: 20 }}
    dataSource={LANGUAGE}
    renderItem={item => {
        const selected = item === lang
        return (<List.Item style={selected ? selectedItemStyle : null}>
          {/* <a onClick={() => doSearch({
          	query, lang: item, sort, order
           })}>{item}</a> */}
            <FilterLink name={item} query={query} lang={item} sort={sort} order={order}/>
          </List.Item>
        )
    }}
/>

```

3. 进一步的优化

- 在Search组件解构router.query时, 解构出来的即通过查询参数都可以当作默认参数, 对于特殊的参数, 在FilterLink中把特殊的参数放到后面

```jsx
const { ...querys } = router.query
const { lang, sort, order } = router.query

// 对于点击语言进行查询, 特殊的参数就是lang, 以及需要显示的列表内容 name
<List.Item>
	<FilterLink {...querys} lang={item} name={item}/>      
</List.Item>

return (
    <List.Item style={selected ? selectedItemStyle : null}>
		<FilterLink { ...querys } name={item.name} sort={item.value} order={item.order}/>
    </List.Item>
)

```

- 当点击Best Match时, url是这样的, http://localhost:3000/search?query=react&lang=&sort=&order=, 其中

sort和order都是空的, 不应该显示

```jsx
const FilterLink = ({ name, query, lang, sort, order }) => {
  // 去掉a标签的onClick事件，在组件内拼接url，使用Link的url
  let querystring = `?query=${query}`
  if (lang) querystring += `&lang=${lang}`
  if (sort) querystring += `&sort=${sort}&order=${order || 'desc'}`

  return (
    <Link href={`/search${querystring}`}>
      <a>{name}</a>
    </Link>
  )
}
```



- 鼠标停在查询条件上, 下面应该显示链接的地址, 可是此时没有显示, 这样会不能使用SEO解析html，进行搜索优化

```jsx
// 同上
```



- 标签选中时还是可以点击的, 实际上是不可以点击的, 加一个是否选中, 选中就显示一个span

```jsx
<List.Item style={selected ? selectedItemStyle : null}>
    {selected ? <span>{item}</span> : 
        <FilterLink
            {...querys}
            name={item}
            lang={item}
            />}
</List.Item>

<List.Item style={selected ? selectedItemStyle : null}>
    {
      selected ? <span>{item.name}</span> :
        <FilterLink {...querys} name={item.name} sort={item.value} order={item.order} />
    }
</List.Item>
```

- 增加一点样式

```jsx
<style jsx>
    {`
    .root {
    	padding: 20px 0;
    }
    .list-header {
        font-weight: 800;
        font-size: 16px;
    }
    `}   
</style>
```

- 优化组件FilterLink, 因为这个组件时纯粹根据props进行更新的, 所以可以使用memo进行优化

```jsx
import { memo } from 'react'
const FilterLink = memo(({ name, query, lang, sort, order }) => {

  let querystring = `?query=${query}`
  if (lang) querystring += `&lang=${lang}`
  if (sort) querystring += `&sort=${sort}&order=${order || 'desc'}`

  return (
    <Link href={`/search${querystring}`}>
      <a>{name}</a>
    </Link>

  )
})
```

### 3. 搜索页面结果页面展示

```jsx
// 所有结果展示, 复用Repo组件
import Repo from '../components/Repo'

{/* 查询结果展示 */}
<Col span={18}>
    <h3 className="repos-title">{repos.total_count}个仓库</h3>
    {
        repos.items.map(repo => <Repo repo = { repo } key = {repo.id} />)
    }
</Col>
<style jsx>{`
	.repos-title {
		font-weight: 800;
		font-size: 20px;
		line-height: 40px;
	}
`}
</style>
```

- 分页

```jsx
import { Row, Col, List, Pagination } from 'antd'

const noop = () => {}
<div className="pagination">
    <Pagination 
        pageSize={30}
        current={ Number(page) || 1}
        total={repos.total_count}
        onChange={noop}
        itemRender={(page, type, ol) => {
            // console.log(page) pagination中的参数page是个标签,需要进行判断
            const p = type === 'page' ? page : type === 'prev' ? page - 1 : page + 1
            const name = type === 'page' ? page : ol
            return <FilterLink {...querys} page = {p} name = {name}/>
        }}
        />
</div>
```



```jsx
const FilterLink = memo(({ name, query, lang, sort, order, page }) => {

  let querystring = `?query=${query}`
  if (lang) querystring += `&lang=${lang}`
  if (sort) querystring += `&sort=${sort}&order=${order || 'desc'}`
  if (page) querystring += `&page=${page}`
  querystring += `&per_page=${per_page}`
  // console.log(isValidElement(name))
  return (
    <Link href={`/search${querystring}`}>
      { isValidElement(name) ? name : <a>{name}</a> }
      {/* <a>{name}</a> */}
    </Link>
  )
})
```

- Search组件中增加参数page

```jsx
const Search = ({ router, repos }) => {
	const { lang, sort, order, page } = router.query
}
```

- 分页样式 居中

```css
.pagination {
    padding: 20px;
    text-align: center;
}
```

pagination,

per_page：每一页显示的记录数



## 仓库详情页

> 思路:
>
> 1. 想布局
> 2. 看布局中使用到的数据, 从组件的getInitialProps中请求后端接口返回结果
> 3. 请求接口会使用一些参数(查询参数,如owner, name), 这些参数从url上下文中获取 ctx.query
>    1. `getInitialProps`入参对象的属性如下：
>       1. `pathname` - URL 的 path 部分
>       2. `query` - URL 的 query 部分，并被解析成对象
>          1. query部分就是?后面的内容, 如 /search?lang=HTML&sort=stars&order=desc中的lang=HTML&sort=stars&order=desc
>       3. `asPath` - 显示在浏览器中的实际路径（包含查询部分），为`String`类型
>       4. `req` - HTTP 请求对象 (只有服务器端有)
>       5. `res` - HTTP 返回对象 (只有服务器端有)
>       6. `jsonPageRes` - [获取数据响应对象](https://github.com/zeit/next.js/tree/7.0.0-canary.8/examples/with-aphrodite) (只有客户端有)
>       7. `err` - 渲染过程中的任何错误
> 4. 加样式

### 1.布局

```jsx
import Repo from '../../components/Repo'
import Link from 'next/link'
import api from '../../lib/api'

const Detail = ({ repoBasic }) => {
  console.log(repoBasic)
  return (
    <div className="root">
      <div className="repo-basic">
        <Repo repo={ repoBasic }/>
        <div className="tabs">
          <Link href="/detail">
            <a className="tab index">Readme</a>
          </Link>
          <Link href="/detail/issues">
            <a className="tab issues">issues</a>
          </Link>
        </div>
      </div>
      <div>Readme</div>
      <style jsx>
        {`
          .root {
            padding-top: 20px;
          }
          .repo-basic {
            padding: 20px;
            border: 1px solid #eee;
            margin-bottom: 20px;
            border-radius: 5px;
          }
          .tab + .tab {
            margin-left: 20px;
          }
        `}
      </style>
    </div>
  )
}
Detail.getInitialProps = async ({ router, ctx }) => {
  const { owner, name } = ctx.query
  // github api: GET /repos/:owner/:repo
  const repoBasic = await api.request({
    url: `/repos/${owner}/${name}`
  }, ctx.req, ctx.res)
  return {
    repoBasic
  }
}

export default Detail
```

>  报错: GET http://localhost:3000/github/repos/undefined/undefined 500 (Internal Server Error)
>
> 如果查看console.log(router), 会显示
>
> Router {route: "/detail", components: {…}, events: {…}, pageLoader: PageLoader, onPopState: ƒ, …}
>
> 这是因为nextjs中, 在getInitialProps中router获取的query是老的信息, 需要使用ctx.query才能获取url中的参数



- 问题: 当我们点击readme或者issues是无法直接带上url: http://localhost:3000/detail?owner=beyondme121&name=appVueFrontEnd中的参数信息的owner=beyondme121&name=appVueFrontEnd

  无法带上参数，也就无法获取仓库的详情!!

  

![detail详情点击带上参数](C:\projects\react-projects\github-next\images\detail详情点击带上参数.png)





创建一个方法

```js
// 入参: 因为从路由拿到的是query对象,key-value对儿
function makeQuery (queryObject) {
  const query = Object.entries(queryObject).reduce((result, entry) => {
    result.push(entry.join('='))
    return result // 别忘了result
  }, []).join('&')
  return `?${query}`
}
```



```jsx
import { withRouter } from 'next/router'

function Detail ({ repoBasic, router }) {
    const query = makeQuery(router.query)
    // ....
    return (
    	// .. 链接拼接上仓库查询需要的参数,参数来自url, 从router中获取, 是通过点击某个仓库,进入/detail?owner=beyondme121&name=backend-nextjs-react中获取的, 然后再点击readme把url中的参数加上去
        <Link href={`/detail${query}`}>
            <a className="tab index">Readme</a>
        </Link>
    )
    
}

export default withRouter(Detail)
```



### 2. 抽取并将布局通用化

- 抽象一个HOC高阶组件, 传入一个具体的页面组件Comp, HOC本身实现通用布局, 渲染Comp
- 高阶组件with-repo-basic.jsx中的参数Comp才是真正的页面组件, 所以要调用页面组件的getInitialProps



> components/with-repo-basic.jsx

```jsx
import Repo from './Repo'
import Link from 'next/link'
import { withRouter } from 'next/router'
import api from '../lib/api'


// 入参: 因为从路由拿到的是query对象,key-value对儿
function makeQuery (queryObject) {
  const query = Object.entries(queryObject)
    .reduce((result, entry) => {
      result.push(entry.join('='))
      return result
    }, []).join('&')
  return `?${query}`
}
/**
 * 这是一个高阶组件HOC: 接收一个组件Comp, return一个组件Detail
 * Comp: 的需要被渲染的组件 (比如不同的不同的内容仓库信息)
 * Detail: 这个组件带有通用的布局代码, 并且把Comp这个定制化的组件内容渲染在Detail组件中
 */
export default function (Comp) {
  function WithDetail({ repoBasic, router }) {
    const query = makeQuery(router.query)
    return (
      <div className="root">
        <div className="repo-basic">
          <Repo repo={repoBasic} />
          <div className="tabs">
            <Link href={`/detail${query}`}>
              <a className="tab index">Readme</a>
            </Link>
            <Link href={`/detail/issues${query}`}>
              <a className="tab issues">Issues</a>
            </Link>
          </div>
        </div>
        <div>
          {/* 每个页面具体的内容 */}
          <Comp />
        </div>
      </div>
    )
  }
  // 调用高阶组件的初始化方法,
  WithDetail.getInitialProps = async ({ ctx }) => {
    const { owner, name } = ctx.query
    // 获取一个仓库的详细信息 github api: GET /repos/:owner/:repo
    const repoBasic = await api.request({
      url: `/repos/${owner}/${name}`
    }, ctx.req, ctx.res)
    return {
      repoBasic: repoBasic.data
    }
  }

  // HOC必须返回一个组件 也就是函数内部声明的组件(函数)
  return withRouter(WithDetail)
}
```

- Detail明细组件

```jsx
// 这个高阶组件用于抽离通用布局, 渲染Detail等需要被渲染的特殊的具体的组件
import withRepoBasic from '../../components/with-repo-basic'

// 这是一个具体的页面, 比如本页面组件, Detail:明细页面, 也可以是Issues: 问题列表页面, 产品页面...
const Detail = ({ text }) => {
  return <span>Detail index, {text}</span>
}
Detail.getInitialProps = async () => {
  return {
    text: 123
  }
}
export default withRepoBasic(Detail)
```

- 预期结果是点击某个仓库, 链接跳转到http://localhost:3000/detail?owner=beyondme121&name=appVueFrontEnd, 布局内容使用withRepoBasic中的通用布局, 并且调用Detail的getInitialProps返回text渲染出Detail index, 123, 但是没有, 问题在哪里???
  - 因为Detail组件返回的是withRepoBasic(Detail), 
  - 而withRepoBasic高阶组件返回的是`return withRouter(WithDetail)`
  - 而WithDetail组件有自己的getInitialProps, 但是并没有调用匿名的高阶组件的参数Comp的getInitialProps方法, 所以也就是没有调用Detail,Issues,Product...的getInitialProps
- 如何解决? 直接在HOC中的getInitialProps直接调用Comp的getInitialProps

```jsx
WithDetail.getInitialProps = async (context) => {
    const { ctx } = context
    const { owner, name } = ctx
    // 获取仓库的信息 api 请求
    const repoBasic = await api.request({
        url: `/repos/${owner}/${name}`
    }, ctx.req, ctx.res)
    // 调用目标组件的初始化方法
    let pageData = {}
    if (Comp.getInitialProps) {
        pageData = await Comp.getInitialProps(context)
    }
    return {
        repoBasic: repoBasic.data,
        ...pageData
    }
}
```

- 然后在WithDetail组件使用ES6的参数收集方式, 把所有的参数传递给目标组件Comp

```jsx
function WithDetail ({ repoBasic, router, /*用于url获取查询参数*/, ...rest }) {
    const query = makeQuery(router.query)
    return (
    	<div className="root">
            {/* 布局代码 */}
            {/* 渲染目标组件Comp, 并把HOC中getInitialProps返回的所有剩余数据向下传递给Comp */}
            <Comp {...rest} />
        </div>
    )
}
```

#### 1. 优化细节(选中不会被点击)

问题: 高阶组件HOC中, 如何区分是ReadMe还是Issuse被点击了呢? 高阶组件中可以接收第二个参数,根据type来判断是渲染span还是链接

```jsx
export default function (Comp, type) {
    function WithDetail ({ 参数 }) {
        return (
        	// ...
            <Comp {...rest}>
        )
    }
    return withRouter(WithDetail)
}
```

- 然后在全局布局中根据type进行渲染

```jsx
{
    type === 'index' ? <span className="tab">ReadMe</span> : 
    	<Link href={`/detail${query}`>
            <a className="tab index">Readme</a>
    	</Link>
}
{
    type === 'issues' ? <span className="tab">Issues</span> : 
    	<Link href={`/detail/issues/${query}`>
            <a className="tab index">Issues</a>
    	</Link>
}
```

**这就nextjs中, 提取固定通用布局的方式, 使用高阶组件, 然后渲染目标特定的组件Comp**, 

**就可以实现不同的页面使用相同的页面布局了**



### 3. 优化之页面切换的缓存

> - 首页初始化时,已经加载了一次仓库的主要basic信息, 当点击某个具体的仓库查看明细时, 还会请求一次basic信息
> - 每次页面切换(点击Readme和Issues)都会请求仓库的basic信息
> - 如何解决? 回顾/pages/index.jsx 也使用了缓存，从缓存中读取数据，那么对应的，在搜索仓库和获取详细的用户的仓库信息时，也可以对数据进行缓存，新建/lib/repo-basic-cache.js



```js
import LRU from 'lru-cache'
// 缓存仓库的基本信息,一般缓存不经常变更的信息
const cache = new LRU({
  maxAge: 1000 * 60 * 60  // 1小时
})

// 设置缓存, 以仓库的full_name为key, 仓库信息对象为value
export function cache (repo) {
  const full_name = repo.full_name
  cache.set(full_name, repo)
}

// 获取仓库信息 full_name: owner/name -> facebook/react
export function get (full_name) {
  return cache.get(full_name)
}
```



- 将缓存的set, get在search页面中进行应用, 但是search页面返回的数据repos是一个**列表**, 不是一个repo对象

```js
// /lib/repo-basic-cache.js 处理列表
export function cacheArray (repos) {
  repos.forEach(repo => set(repo))
}
```

- detail页面每一次渲染都要一次useEffect修饰的缓存数据插入

```jsx
import { useEffect } from 'react'
import { cacheArray } from '../lib/repo-basic-cache'

function Search ({ repos, router}) {
  // 每次渲染Search都会调用cacheArray对查询出来的repos数组列表进行缓存, 
  // 因为cacheArray调用的是cache函数, cache函数是根据key(full_name)进行缓存的cache.set(full_name, repo)
  // 即便full_name重复了也没有关系, 就类似对象的属性一样, 即使full_name重复了, 也会覆盖之前的full_name对象的缓存
  useEffect(() => {
    cacheArray(repos)
  })
}
```

- Search页面获取完数据之后也缓存了, 就在HOC中获取缓存, 最后在HOC入参的组件就可以使用缓存数据了

> 也就是组件的数据流是: 
>
> 1. Search中初始化每一个仓库的基础信息(repos)，并设置cacheArray数据进行缓存
> 2. 在高阶组件with-repo-basic中获取get函数
> 3. 然后在详情页中/detail/index.js, 根据full_name的key获取使用缓存之后的数据
>
> 

```jsx

```

- 再次优化, useEffect(() => {}) 是针对的用户端的, 但是代码也会在服务端渲染进行执行,所以要判断是否为服务端, 服务端渲染是没有必要执行的, 执行越多, 服务端的内存被没有意义的使用, **因为useEffect是与用户搜索有关的**, 所以要屏蔽服务端渲染，所以
  - 在Search以及with-repo-basic都要判断是否为服务端

```js

const isServer = typeof window === 'undefined'

// Search
import { cacheArray } from '../lib/repo-basic-cache'
useEffect(() => {
    if (!isServer) {
        cacheArray(repos.items)
    }
})

// with-repo-basic.jsx
import { get, cache } from '../lib/repo-basic-cache'
if (!isServer) {
    cache(repoBasic)
}
```

- 还有一个问题, 就是已经到了详情页, 点击issues之后要请求一次数据, 然后再点击Readme才会使用缓存

> 这是因为在服务端渲染完成之后,客户端在第一次渲染的时候是不会调用页面或者组件的getInitialProps的
>
> 所以cache(repoBasic) 要移动到组件的渲染中去做, 而不是放在组件的getInitialProps的方法中去做
>
> 所以同样的, 也要导入useEffect

```jsx
import { useEffect } from 'react'

export default function (Comp, type = 'index') {
	function WithDetail ({ repoBasic, router, ...rest }) {
        useEffect(() => {
            if (!isServer) {
                cache(repoBasic)
            }
        })
    }
}
```

### 4. useEffect复习

- **无需清除的 effect**

  - 比如发送网络请求，手动变更 DOM，记录日志，这些都是常见的无需清除的操作
  - 因为我们在执行完这些操作之后，就可以忽略他们了
  - 保存useEffect修饰的函数,并在DOM更新完成之后调用这个函数effect
  - 它在第一次渲染之后*和*每次更新之后都会执行 当然也可以控制

- **需要清楚的effect**

  - **订阅外部数据源**
  - 这种情况下，清除工作是非常重要的，可以防止引起内存泄露
  - 如果你的 effect 返回一个函数，React 将会在执行清除操作时调用它

  

```jsx
import { useEffect } from 'react'
const Demo = () => {
    useEffect( () => {
        function fn () {...}
        fn()
        // effect函数返回一个函数, 会执行这个函数
		return () => {
            console.log('clear...')
        }
    })
}
```



### 5. 获取markdown内容并转义

- 获取readme的数据
- 转换markdown文档

```jsx
import api from '../../lib/api'

const Detail = ({ readme }) => {
    console.log(reamde) // 是个对象 其中有content
    return (
    	<div>
        	<span>Detail index</span>
        </div>
    )
}

Detail.getInitialProps = async ({ ctx: { query: { owner, name }, req, res }}) => {
    const readmeResp = await api.request({
        url: `/repos/${owner}/${name}/readme`
    }, req, res)
    return {
        readme: readmeResp.data
    }
}
```

- 浏览器中, readme对象中的content属性, Console中右键store global variable就会自动创建变量temp1, 然后使用浏览器中自带的全局函数atob(temp1)就可以转化base64的类似乱码的内容为可以识别的markdown文档

- 但是当刷新页面之后, 就会出现如下错误, 原因是, 刷新又重新请求了后端服务器, 服务端nodejs没有自带这个函数, 需要安装atob包 yarn add atob, 然后在server.js中将这个函数挂载到全局global上

>  ReferenceError: atob is not defined 

- server.js

```js
const atob = require('atob')
global.atob = atob
```

### 6. 将md转移为html

`yarn add markdown-it`

`yarn add github-markdown-css`

#### 0. 思路

> 1. 使用markdown-it将md转化为html
> 2. 使用github-markdown-css来美化html
> 3. 中文乱码问题, atob没法直接将中文转码, 定义base64转换为utf8编码的函数
> 4. 图片img的链接是字符串, 给markdownIt传递html参数为true, 就可以转换为html而不是字符串

```jsx
import MarkdownIt from 'markdown-it'
import 'github-markdown-css'
const md = MarkdownIt({
	html: true,			// 将markdown语法的字符串转换为html
    linkify: true,		// 转换为可以点击的链接
})

function b64
const Detail = ({ readme }) => {
  const content = atob(readme.content)
  const html = md.render(content)
  return (
    <div dangerouslySetInnerHTML={{ __html: html }}></div>
  )
}
```

#### 1. 完成功能

> 在Detail明细页面中杂糅了显示markdown页面和实现markdown转换为html功能的代码

```jsx
import MarkdownIt from 'markdown-it'
import 'github-markdown-css'

// 这个高阶组件用于抽离通用布局, 渲染Detail等需要被渲染的特殊的具体的组件
import withRepoBasic from '../../components/with-repo-basic'

import api from '../../lib/api'

const md = MarkdownIt({
  html: true,     // md转换为html, 图片就可以直接引用显示而不是现实字符串 
  linkify: true   // md中链接可被点击
})

// 将base64编码转化为utf8编码
function b64_to_utf8 (str) {
  return decodeURIComponent(escape(atob(str)))
}

// 这是一个具体的页面, 比如本页面组件, Detail:明细页面, 也可以是Issues: 问题列表页面, 产品页面...
const Detail = ({ readme }) => {
  let content = b64_to_utf8(readme.content)
  content += `This is http://www.baidu.com`
  const html = md.render(content)
  return (
    <div className="markdown-body">
      <div dangerouslySetInnerHTML={{ __html: html }}></div>
    </div>
  )
}

Detail.getInitialProps = async ({ ctx: { query: { owner, name }, req, res }}) => {
  const readmeResp = await api.request({
    url: `/repos/${owner}/${name}/readme`
  }, req, res)
  return {
    readme: readmeResp.data
  }
}
export default withRepoBasic(Detail, 'index')
```

#### 2. 抽离渲染markdown组件为单独的组件

```jsx
// 因为是一个每次都要渲染的组件, 使用useMemo
import MarkdownIt from 'markdown-it'
import 'github-markdown-css'

const md = new MarkdownIt({
  html: true,
  linkify: true
})

function b64_to_utf8 (str) {
  return decodeURIComponent(escape(atob(str)))
}

export default function MarkdownRenderer ({ content, isBase64 }) {
  const markdown = isBase64 ? b64_to_utf8(content) : content
  const html = md.render(markdown)
  return (
    <div className="markdown-body">
      <div dangerouslySetInnerHTML={{ __html: html }}></div>
    </div>
  )
}

```

#### 3. 在Detail组件中引入这个抽离的组件并传递参数

```jsx
import MDRenderer from '../../components/MarkdownRenderer'
const Detail = ({ readme }) => {
    return (
        <MDRenderer content = { readme.content} isBase64={true}/>
    )
}
// props是通过 pages/index.js或者search出来的结果,展示Repo组件(/components/Repo),其中每个仓库都是link路由跳转到detail页面
// 所以就Detail页面就是通过router.query来接收props参数, 用于查询
Detail.getInitialProps = async ({ ctx: { query: { owner, name }, req, res }}) => {
    const readmeResp = await api.request({
        url: `/repos/${owner}/${name}/readme`
    }, req, res)
    return {
        readme: readmeResp.data
    }
}
```

> Repo组件对于每个仓库列表添加了router跳转的链接

```jsx

<Link href={`/detail?owner=${repo.owner.login}&name=${repo.name}`}>
    <a>{repo.full_name}</a>
</Link>
```

#### 4. 优化

- 每次都要渲染的组件, 而且组件的渲染只与props有关, 如果props没有发生变化组件就没有必要重新渲染
- md.render渲染挺耗时的,如果markdown没有发生变化,我们就缓存渲染之后的结果html
- 执行副作用的函数,通常使用useCallback， 
- `useCallback(fn, deps)` 相当于 `useMemo(() => fn, deps)`。 
- 这个组件是否有必要使用dynamic 动态引入组件呢?

```jsx
import { memo, useMemo } from 'react'
function b64_to_utf8 (str) {
    return decodeURIComponent(escape(atob(str)))
}
export default memo(function MarkdownRenderer({ content, isBase64}) {
    const markdown = isBase64 ? b64_to_utf8(content) : content
    // md.render渲染挺耗时的,如果markdown没有发生变化,我们就缓存渲染之后的结果html
    const html = useMemo(() => md.render(markdown), [markdown])
    return (
        <div className="markdown-body">
          <div dangerouslySetInnerHTML={{ __html: html }}></div>
        </div>
    )
})
```

### 7. 打包分析

```js
yarn add @zeit/next-bundle-analyzer
```

- 在next.config.js中

```js
const withBundleAnalyzer = require('@zeit/next-bundle-analyzer')
module.exports = withBundleAnalyzer(withCSS({
  // 使用webpack的analyzer的分析插件,帮助分析打包出来的js的依赖关系
  analyzeBrowser: ['browser', 'both'].includes(process.env.BUNDLE_ANALYZE),
  bundleAnalyzerConfig: {
    // 生成的分析报告产出在什么目录未知
    server: {
      analyzerMode: 'static',
      reportFilename: '../bundles/server.html'
    },
    browser: {
      analyzerMode: 'static',
      reportFilename: '../bundles/client.html'
    },
  }
}))
```

- 在package.json中添加script命

```json
"analyze:browser": "cross-env BUNDLE_ANALYZE=browser next build"
```

- 安装crosss-env这个包

> 用途: BUNDLE_ANALYZE=browser 这种写法叫做环境变量,在启动next build构建项目的时候, 可以通过process.env.BUNDLE_ANALYZE获取browser这个值，这种方式可以在linux和mac中可以获取到值,也就是有这种写法, 但是在window下是不支持的。所以cross-env就可以跨越操作系统之间的差异
>
> `yarn add cross-env`

- 运行命令, npm run analyze:browser, 查看打包后js的文件的依赖关系

![next-bundle-analyzer分析项目打包之后js之间的依赖关系图](C:\projects\react-projects\github-next\images\next-bundle-analyzer分析项目打包之后js之间的依赖关系图.png)

- 接下来我们分析一下Markdown组件我们使用dynamic进行import

```jsx
// detail/index.jsx
import dynamic from 'next/dynamic'
const MDRender = dynamic(() => import('../../components/MarkdownRenderer'))
// 把原来的import MDRenderer from '../../components/MarkdownRenderer'注释掉
// import MDRenderer from '../../components/MarkdownRenderer
```

> 打包之后,会多出一个js文件, detail的js文件变小了, MDRender会存储在新生成的js文件中, 其实在每次请求detail页面时, 并没有少加载文件大小, 反而多加载了一个js文件，多了一次http请求
>
> 但是, 这个新生成的文件是不变的, hash值不变, 那么这个js文件就可以长期缓存在浏览器中


![](C:\projects\react-projects\github-next\images\dynamic-import动态加载.png)



- 通过这个分析报告我们知道,还需要优化一下moment, 因为我们只需要支持中文, 分析报告中加载了其他语言

```js
// next.config.js
const webpack = require('webpack')
module.exports = withBundleAnalyzer(
    withCSS({
      webpack (config) {
        // 忽略所有和locale相关的js文件
        config.plugins.push(new webpack.IgnorePlugin(/^\.\/locale$/, /moment$/))
        // 必须返回config
        return config
      }
  	})
)

```

- dynamic动态import组件,当动态加载组件还没有完成的时候,可以传递给这个函数第二个参数

```jsx
const MDRenderer = dynamic(
  () => import('../../components/MarkdownRenderer'),
  // dynamic动态加载组件未完成时, 传递第二个参数, 配置项, loading配置项, 一个组件 
  {
    loading: () => <p>loading...</p>
  }
)
```



### 8. issue页面

#### 1. 页面数据请求

```jsx
import { Avatar } from 'antd'
import withRepoBasic from '../../components/with-repo-basic'
import api from '../../lib/api'

const IssueItem = ({ issue }) => {
  return (
    <div className="issue">
      <div className="avatar">
        <Avatar src={issue.user.avatar_url} shape="square" />
      </div>
    </div>
  )
}
const Issues = ({ issues }) => {
  return (
    <div className="root">
      <div className="issues">
        {
          issues.map(item => <IssueItem issue={item} key={item.id} />)
        }
      </div>
    </div>
  )
}

Issues.getInitialProps = async ({ ctx }) => {
  const { owner, name } = ctx.query

  const issuesResp = await api.request({
    url: `/repos/${owner}/${name}/issues`
  }, ctx.req, ctx.res)

  return {
    issues: issuesResp.data
  }
}

export default withRepoBasic(Issues, 'issues')
```



#### 2. 页面解构与样式

- IssueItem

```jsx
const IssueItem = ({ issue }) => {
  return (
    <div className="issue">
      <div className="avatar">
        <Avatar src={issue.user.avatar_url} shape="square" />
      </div>
      <div className="main-info">
        <h6>
          <span>{issue.title}</span>
        </h6>
        <div className="sub-info">
          <span>Updated at {issue.updated_at}</span>
        </div>
      </div>
      <style jsx>{`
        .issue {
          display: flex;
          position: relative;
        }
        .issue:hover {
          background-color: #fafafa;
        }
        .issue + .issue {
          border-top: 1px solid #eee;
        }
        .main-info > h6 {
          max-width: 600px;
          font-size: 16px;
          padding-right: 60px;
        }
        .avatar {
          margin-right: 20px
        }
        .sub-info {
          margin-bottom: 10px;
        }
        .sub-info > span + span {
          display: inline-block;
          margin-left: 20px;
          font-size: 12px;
        }
      `}</style>
    </div>
  )
}
```

- Issue

```jsx
const Issues = ({ issues }) => {
  return (
    <div className="root">
      <div className="issues">
        {
          issues.map(item => <IssueItem issue={item} key={item.id} />)
        }
      </div>
      <style jsx>
        {`
          .issues {
            border: 1px solid #eee;
            border-radius: 5px;
            margin-bottom: 20px;
            margin-top: 20px;
          }
        `}
      </style>
    </div>
  )
}
```

#### 3. 处理点击事件

- IssueItem中添加按钮, 点击"查看",显示issue的内容, 点击隐藏收缩内容(version1)

```jsx
import { useState} from 'react'
const toggleShowDetail = () => {
    setShowDetail(!showDetail)
}
const [showDetail, setShowDetail] = useState(false)
<Button type="primary" size="small" style={{postion: "absolute", top: 10, right: 10}}
    onClick={toggleShowDetail}
    >
   { showDetail ? '隐藏' : '查看' }
</Button>
```

- 优化 使用useCallback

> 使用callback的方式更新我们的state, 而不是直接依赖useState返回的state, 这样就不用依赖外部声明的变量，就逃过了闭包!!! 所以在使用hook，逃过闭包是一个重要的课题

```jsx
import { useState, useCallback } from 'react'
const toggleShowDetail = useCallback(() => {
    setShowDetail(detail => !detail)	
}, [])
```

- 点击查看显示issueDetail详情

```jsx
const MDRenderer = dynamic(() => import("../../components/MarkdownRenderer"));

// issue详情页面
function IssueDetail ({ issue }) {
  return (
    <div className="root">
      <MDRenderer content={issue.body} />
      <div className="actions">
        <Button href={issue.html_url} target="_blank">
          打开issue详情
        </Button>
      </div>
      <style jsx>{`
        .root {
          background: #fefefe;
          padding: 20px;
        }
        .actions {
          text-align: right;
        }
      `}</style>
    </div>
  );
}
```

- 根据issueItem中维护的showDetail的状态来判断是否显示详情页面IssueDetail

```jsx
const IssueItem = ({ issue }) => {
    return (
    	<div>
        	<div className="root">
        	</div>
            { showDetail ? <IssueDetail issue={issue}/> : null }
        </div>
    )
}
```



#### 4. 创建用户搜索组件

0. 中后台的筛选条件开发

1. 查找某个仓库的issues
2. 根据labels查询过滤指定的issues
3. 搜索github上的用户 `GET /search/users?q=xxx`
   1. 搜索框中输入关键字, 然后加载搜索的用户结果列表, 然后再选择某个用户(中后台的帅选的功能) /components/SearchUser.jsx



```jsx

```



- 输入框用户输入文本查询select的option选项的回调 onSearch的回调fetchUser
- 每次输入都会触发后端请求, 需要加入debounce



```jsx
// SearchUser.js
import debounce from 'lodash/debounce'

// SearchUser组件内的方法 fetchUser
const fetchUser = debounce(fn, 500) // 500毫秒之后没有操作才执行fn

```

- 小优化 useCallback 优化fetchUser函数

> 因为fetchUser依赖的是两个状态的set函数, 函数都不会变化, 所以使用useCallback可以不写依赖项



- 设置id, 解决上次查询数据还没有结束, 第二次查询就开始了, 返回的数据不希望是第一次的然后第二次的结果返回之后替换第一次的结果, 不希望是页面替换而是直接返回第二次的结果
  - 使用useRef 逃过闭包

```jsx
// 请求开始的fetchId
lastFetchIdRef.current += 1
// 当前向后端请求的fetchId
const fetchId = lastFetchIdRef.current

// 在api请求的时候判断, 两个是否一致, 如果不一致就抛弃之前的id请求

```



- Issues组件使用SearchUser组件

```jsx
import { useState } from 'react'

const [creator, setCreator] = useState()

const handleCreatorChange = () => {
    
}


<SearchUser onChange={} value={creator}/>
```

#### 5. 状态组件搜索

```jsx
// repos的状态
  const [state, setState] = useState()
  const handleStateChange = useCallback((value) => {
    setState(value)
  }, [])

{/* 状态下拉框选择 */}
      <Select onChange={handleStateChange} value={state} placeholder="状态" style={{ width: 200 }}>
        <Option value="all">all</Option>
        <Option value="open">open</Option>
        <Option value="close">close</Option>
      </Select>
```



#### 6. label查询



- issues数据, 
  - 初始化数据的时候是没有查询参数的, 即通过api: url: `/repos/${owner}/${name}/issues`
  - 当用户通过选择用户，label，状态等下拉选项，点击查询得到issues的结果是通过其他参数的url进行请求的, 所以初始化的issues数据













## 扩展知识

### 1. vscode设置

perference-settings中搜索asso..之后,点击编辑json文件, 添加配置项, js后缀的文件就可以被识别为react代码了

```json
"files.associations": {
        "*.js": "javascriptreact"
},
```

```json
{
    "editor.tabSize": 2,
    "terminal.integrated.shell.windows": "C:\\Program Files\\Git\\bin\\bash.exe",
    "[javascript]": {
        "editor.defaultFormatter": "vscode.typescript-language-features"
    },
    "editor.fontSize": 16,
    "[html]": {
        "editor.defaultFormatter": "vscode.html-language-features"
    },
    "editor.foldingStrategy": "indentation",
    "emmet.includeLanguages": {
        "javascript": "javascriptreact"
    },
    "[javascriptreact]": {
        "editor.defaultFormatter": "vscode.typescript-language-features"
    },
    "workbench.iconTheme": "vscode-icons",
    "editor.formatOnPaste": false,
    "editor.formatOnSave": true,
    "editor.formatOnType": false,
    "editor.fontFamily": "'Fira Code Retina', 'Microsoft Yahei UI'",
    "editor.fontLigatures": true,
    "editor.suggest.snippetsPreventQuickSuggestions": false,
    //"editor.fontFamily": "'Fira Code', Consolas, 'Courier New', monospace"
    "files.associations": {
        "*.js": "javascriptreact"
    },
    "prettier.jsxBracketSameLine": true
}
```



### 2.MacOS安装redis

- 下载安装包并解压redis-5.0.5

```
$ tar xzf redis-5.0.5.tar.gz
$ cd redis-5.0.5
$ make
```

- 修改配置文件

**找到redis.conf 并修改 daemonize no 为 daemonize yes ，这样就可以默认启动就后台运行**

- 启动服务端和客户端连接

```
//
./src/redis-server ../redis.conf
./src/redis-cli
```



### 3. 解决github提交问题

**Git The requested URL returned error: 403**

> https://www.jianshu.com/p/a1908f55bef8
>
> - `git config --local --unset credential.helper`
> - `git config --global --unset credential.helper`
> - `git config --system --unset credential.helper`
> - **git config --global credential.helper store**
> - 最后push时, 输入用户名密码就可以了 git push -u origin master





## style-jsx

这种方式引入的样式在不同组件之间不会相互影响，甚至父子组件之间都不会相互影响

## 避坑

1. 配置文件一定要重启, 即使使用了nodemon, 也要重启

```js
module.exports = withCSS({
  env: {
    customerKey: 'A0001',     // 页面使用process.env.customerKey获取
  },
  publicRuntimeConfig: {
    customerKey: 'A0002'
  }
})
```



## github认证

### 配置文件保存github oauth


