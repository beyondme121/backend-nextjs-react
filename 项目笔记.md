# Github NextJS REACT项目实战

## 技术点

- nextjs
- react+antd
- 数据库
- 接口代理
- 数据同步
  - 用户登录后,再次刷新页面,不用再次请求接口获取数据再渲染页面
- 数据缓存
  - 第一次点击加载数据, 然后回退, 再次点击, 就不再加载，数据就缓存在页面上
  - 服务端渲染的时候，一开始就进入的页面，也要直接缓存，不希望在页面切换后，再次重新加载，就是请求的链接，直接就是缓存到页面上的，不需要请求服务端的数据，再渲染到页面



## 初始化项目

- ```
  npm init -y
  yarn add react react-dom next @zeit/next-css antd axios koa koa-router koa-session babel-plugin-import ioredis redux react-redux redux-devtools-extension redux-thunk redux-saga babel-plugin-styled-components styled-components
  ```

- 让项目跑起来

1. 新建pages目录, 创建index.jsx

```jsx
export default () => {
    return <div>hello</div>
}
```

2. 修改package.json

```json
"scripts": {
    "dev": "next",
    "build": "next build",
    "start": "next start"
},
```

3. npm run dev启动

4. 集成antd

   > 1. next项目不能直接import 一个css文件  next.config.js中配置
   > 2. 解决前端使用import语法
   > 3. antd的按需加载组件

   next.config.js

   ```js
   const withCSS = require('@zeit/next-css')
   if (typeof require !== 'undefined') {
     require.extensions['css'] = file => {}
   }
   module.exports = withCSS({})
   ```

   .babelrc

   ```json
   {
     "presets": ["next/babel"],
     "plugins": [
       [
         "import",
         {
           "libraryName": "antd"
         }
       ]
     ]
   }
   ```

   _app.js 覆盖next自带的App组件, 进行定制化应用, 全局引入antd样式

   ```js
   import App from 'next/app'
   import 'antd/dist/antd.css'
   export default App;
   ```

   index.jsx中使用antd组件

   ```jsx
   import { Button } from 'antd'
   
   export default () => {
     return <div>
       <Button>hello world</Button>
     </div>
   }
   ```



## 项目布局

1. 整体布局使用antd中的Layout, 在components写整体布局, 然后在_app.js中引入并覆盖next自带的App

components/Layout.jsx

```jsx
// 全局布局
import { Layout, Icon, Input, Avatar } from 'antd'
import { useState, useCallback } from 'react'
const { Header, Content, Footer } = Layout
export default ({ children }) => {
  // 增加组件的状态, 因为涉及到用户的输入,进行查询仓库内容
  const [search, setSearch] = useState('')
  // 处理用户输入修改状态数据
  const handleSearchChange = useCallback((e) => {
    setSearch(e.target.value)
  }, [setSearch])
  // antd中对Input.Search组件中onSearch的回调函数,用户在输入框中输入完成后, 处理用户点击搜索和回车
  const handleOnSearch = useCallback(() => {})
  return (
    <Layout>
      <Header>
        <div className="header-left">
          <div>
            <Icon type="github"></Icon>
          </div>
          <div>
            <Input.Search placeholder="搜索仓库" value={search} onChange={ handleSearchChange } onSearch={ handleOnSearch } ></Input.Search>
          </div>
        </div>
        <div className="header-right">
          <div className="user">
            <Avatar size = {40} icon="user" />
          </div>
        </div>
      </Header>
      <Content>
        { children }
      </Content>
      <Footer>
        Develop by Zhicheng Liu @<a href="mailto:zhicheng.liu@cn.abb.com">Zhicheng.Liu@cn.abb.com</a>
      </Footer>
    </Layout>
  )
}
```

2. layout 引入到_app.js中，并继续写Layout.jsx, 继续完善, header的样式

- 由于antd的Header组件是不会增加到html标签节点上的, 所以要单独在Header内部写个div然后设置样式

```jsx
<Header>
	<div className="header-inner">
	{/* 省略... */}
	</div>
</Header>
// 设置header整体的布局样式
<style jsx>{`
    .header-inner {
        display: flex;
        justify-content: space-between;
    }
    .header-left {
        display: flex;
        justify-content: flex-start;
    }
`}
</style>
{/* 全局样式设置, content内部不够会被挤压的解决样式, 让外层的id和layout的类的height为100% */}
<style jsx global>{`
    #__next, .ant-layout {
    	height: 100%;
    }
`}
</style>
```

- 设置图标GITHUB字体样式和footer的样式

```jsx
// header中 github图标Icon的样式,写在外面是这个style永远不会变, 以后组件渲染不用重新定义对象, 
// 保证了每次header组件中使用的组件github样式是同一个对象, 节省内存
const githubIconStyle = {
  color: 'white',
  fontSize: 40,
  display: 'block',
  paddingTop: 10,
  marginRight: 20,
}
const footerStyle = {
  textAlign: 'center'
}

// 组件return
<div>
    <Icon type="github" style={githubIconStyle}></Icon>
</div>
<Footer style={footerStyle} >...</Footer>
```



## 扩展组件

**cloneElement扩展组件可复用性的高级技巧**

1. 削减代码页面标签的数量
2. 代码整洁
3. components/Container组件

- 业务目标
  - 实现Container组件, 让被它包裹的所有组件都能宽度100%, 左右居中, 并设置最大宽度 Container.jsx

```jsx
const style = {
  width: '100%',
  maxWidth: 600,
  marginLeft: 'auto',
  marginRight: 'auto'
}
export default ({ children }) => {
  return <div style={style}>{children}</div>
}
```

- 问题来了, 我们想修改container中的字体为红色, 如下完全可以满足需求, 即给Container容器组件添加一个div, 然后给div添加className, 但是我们希望把Container当作标签, 传递属性的方式修改Container的样式

```jsx
<Content>
	<Container>
    	<div className={content}>
        	{ children }
        </div>
    </Container>
</Content>
<style jsx>{`
	.content {
		color: red;
	}
`}
</style>

```



- Constainer.jsx

```jsx
import { cloneElement } from 'react'

const style = {
  width: '100%',
  maxWidth: 1200,
  marginLeft: 'auto',
  marginRight: 'auto',
  paddingLeft: 20,
  paddingRight: 20
}

/**
 * 1. Constainer组件接收的是一个jsx的标签, 等同于React.createElement('div) 标签类型, 返回的element类型
 * 2. clone传递进来的element类型的"jsx或者组件", 然后使用Container组件的props覆盖clone的element
 * 3. 扩展节点: 对传入的节点(renderer), 增加props属性(如本例增加style), 来新增或覆盖传递进来的节点, 达到扩展组件或节点的目的
 */
export default ({ children, renderer = <div />}) => {
  console.log(renderer);
  const newElement =  cloneElement(renderer, {
    style: Object.assign({}, renderer.props.style, style),  // 合并style, 将用户自定义的style和本组件设置的style进行合并
    children
  })
  console.log(newElement);
  return newElement;
}

```

- 创建一个测试组件, 组件可以接收的参数props有: color, style, children

```jsx
const MyComp = ({ color, style, children }) => <div style={ color, ...style }>
    { children }
</div>
```

- Layout.jsx中使用Container组件,该传递props就传递, color,

```jsx
<Constainer renderer={<Comp color="red" style={{ fontSize: 40 }}>}>
	{ children } 
</Constainer>
```

- 总结

传入一个组件Comp, 这个组件带有自身样式或者特性, 然后clone这个组件或者jsx, cloneElement, 然后封装组件Container有自定义好的样式或者特性, 然后将Comp中的props和Container中的属性进行对象属性合并

- 调整header中antd自带的样式, 对header-inner的样式div增加Container的样式

```jsx
<Header>
    <Container renderer={<div className="header-inner" />}>
        {/* .... */}
    </Container>
</Header>
```

- header的左右padding为50, 去掉, 踩坑: 样式之间不是以逗号分隔的

```jsx
<style jsx global>
	{`
        #__next, .ant-layout {
            height: 100%;
        }
		// 此处不能加"逗号" , 
        .ant-layout-header {
            padding-left: 0!important;
            padding-right: 0!important;
        }
    `}
</style>
```



## 服务端渲染同步用户信息

1. 在next服务端渲染前, 给ctx.req.session 赋值为ctx.session
2. 然后在redux初始化的地方
3. 服务端渲染,初始状态正确, 刷新之后, 状态数据，前端改变的数据和服务端数据不一致的问题解释
4. 后端server不需要提供一个接口, 然后前端请求接口, 后端返回github用户数据, 最后前端再拿到userInfo, 其实是不需要的, github认证以及获取数据可以在next服务端渲染之前, 把ctx.req.session = ctx.session
5. 赋值之后, 在redux初始化的时候, withRedux.js中, getOrCreateStore函数接收initState, 就可以把这个session设置到全局了
6. 再看store.js, 

- 服务端渲染, 通过react代码通过webpack打包生成的js，会放在.next目录下
- 然后server.js启动服务后, 会动态加载打包之后的js,也就是把打包的js当作Nodejs模块，
- 我们就可以认为，服务端渲染的时候，store.js可以认为是nodejs的模块，`export default store`
- 既然认为是nodejs的模块, store.js代码中导出的store对象就是独一份的, 是共享的
- 也就是它**不会**在每次服务端渲染时, 都会生成一份新的store
- 服务端渲染，store.js在被加载的时候, 已经被生成好了, 服务器在启动之后并不是每次都要重启服务器
- 那么在服务器启动之后, 服务端渲染就都使用同一个store对象
- 这就导致了，状态改变了，是不会进行重置的，默认初始状态是0



代码 server.js中, 所有请求的中间件中, 设置ctx.req.session = ctx.session

> ctx.session其实做了两件事
>
> 通过koa-session这个包对ctx增加了session属性
>
> 通过auth(server)  通过判断路径为/auth进行鉴权时, 满足登录条件的,把userInfo用户信息设置到ctx.session的属性上 如，ctx.session.userInfo

```js
server.use(async (ctx, next) => {
    ctx.req.session = ctx.session
    await handle(ctx.req, ctx.res)	// 服务端返回数据给客户端
    ctx.respond = false
})
```

- 我们希望的是, 在应用初始化的时候, 就把用户的session设置进来

比如, withRedux(MyApp), 在withRedux中, 服务端初始化时(WithRedux.getInitialProps = fn)中，创建store, {getOrCreateStore(服务端初始化用到的参数)}，比如这个参数由user信息。

如何设置的initialState呢? 核心代码是

```js
if (isServer) {
      // 解构的req可能是不存在的,只有在服务端渲染的时候才会存在, 前端切换路由也会执行getInitialProps
      const { req } = ctx.ctx
      const session = req.session
      if (session && session.userInfo) {
    	reduxStore = getOrCreateStore({
          user: session.userInfo
        })
      } else {
 		 reduxStore = getOrCreateStore()       
      }
    
}
```

```js
WithRedux.getInitialProps = async (ctx) => {
    let reduxStore
    if (isServer) {
      // 解构的req可能是不存在的,只有在服务端渲染的时候才会存在, 前端切换路由也会执行getInitialProps
      const { req } = ctx.ctx
      const session = req.session
      // if (session && session.userInfo) {
      if (true) {	// 因为没有登录,测试是否可以设置initialState
        reduxStore = getOrCreateStore({
          user: {
            username: 'sanfeng',
            age: 18
          }
        })
      } else {
        reduxStore = getOrCreateStore()
      }
    } else {
      reduxStore = getOrCreateStore()
    }

  }
  return WithRedux
```





## style-jsx

这种方式引入的样式在不同组件之间不会相互影响，甚至父子组件之间都不会相互影响

## 避坑

1. 配置文件一定要重启, 即使使用了nodemon, 也要重启

```js
module.exports = withCSS({
  env: {
    customerKey: 'A0001',     // 页面使用process.env.customerKey获取
  },
  publicRuntimeConfig: {
    customerKey: 'A0002'
  }
})
```



## github认证

### 配置文件保存github oauth



## 获取用户信息

- Layout.jsx

```jsx

```

