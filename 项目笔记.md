# Github NextJS REACT项目实战

## 技术点

- nextjs
- react+antd
- 数据库
- 接口代理
- 数据同步
  - 用户登录后,再次刷新页面,不用再次请求接口获取数据再渲染页面
- 数据缓存
  - 第一次点击加载数据, 然后回退, 再次点击, 就不再加载，数据就缓存在页面上
  - 服务端渲染的时候，一开始就进入的页面，也要直接缓存，不希望在页面切换后，再次重新加载，就是请求的链接，直接就是缓存到页面上的，不需要请求服务端的数据，再渲染到页面



## 初始化项目

- ```
  npm init -y
  yarn add react react-dom next @zeit/next-css antd axios koa koa-router koa-session babel-plugin-import ioredis redux react-redux redux-devtools-extension redux-thunk redux-saga babel-plugin-styled-components styled-components
  ```

- 让项目跑起来

1. 新建pages目录, 创建index.jsx

```jsx
export default () => {
    return <div>hello</div>
}
```

2. 修改package.json

```json
"scripts": {
    "dev": "next",
    "build": "next build",
    "start": "next start"
},
```

3. npm run dev启动

4. 集成antd

   > 1. next项目不能直接import 一个css文件  next.config.js中配置
   > 2. 解决前端使用import语法
   > 3. antd的按需加载组件

   next.config.js

   ```js
   const withCSS = require('@zeit/next-css')
   if (typeof require !== 'undefined') {
     require.extensions['css'] = file => {}
   }
   module.exports = withCSS({})
   ```

   .babelrc

   ```json
   {
     "presets": ["next/babel"],
     "plugins": [
       [
         "import",
         {
           "libraryName": "antd"
         }
       ]
     ]
   }
   ```

   _app.js 覆盖next自带的App组件, 进行定制化应用, 全局引入antd样式

   ```js
   import App from 'next/app'
   import 'antd/dist/antd.css'
   export default App;
   ```

   index.jsx中使用antd组件

   ```jsx
   import { Button } from 'antd'
   
   export default () => {
     return <div>
       <Button>hello world</Button>
     </div>
   }
   ```



## 项目布局

1. 整体布局使用antd中的Layout, 在components写整体布局, 然后在_app.js中引入并覆盖next自带的App

components/Layout.jsx

```jsx
// 全局布局
import { Layout, Icon, Input, Avatar } from 'antd'
import { useState, useCallback } from 'react'
const { Header, Content, Footer } = Layout
export default ({ children }) => {
  // 增加组件的状态, 因为涉及到用户的输入,进行查询仓库内容
  const [search, setSearch] = useState('')
  // 处理用户输入修改状态数据
  const handleSearchChange = useCallback((e) => {
    setSearch(e.target.value)
  }, [setSearch])
  // antd中对Input.Search组件中onSearch的回调函数,用户在输入框中输入完成后, 处理用户点击搜索和回车
  const handleOnSearch = useCallback(() => {})
  return (
    <Layout>
      <Header>
        <div className="header-left">
          <div>
            <Icon type="github"></Icon>
          </div>
          <div>
            <Input.Search placeholder="搜索仓库" value={search} onChange={ handleSearchChange } onSearch={ handleOnSearch } ></Input.Search>
          </div>
        </div>
        <div className="header-right">
          <div className="user">
            <Avatar size = {40} icon="user" />
          </div>
        </div>
      </Header>
      <Content>
        { children }
      </Content>
      <Footer>
        Develop by Zhicheng Liu @<a href="mailto:zhicheng.liu@cn.abb.com">Zhicheng.Liu@cn.abb.com</a>
      </Footer>
    </Layout>
  )
}
```

2. layout 引入到_app.js中，并继续写Layout.jsx, 继续完善, header的样式

- 由于antd的Header组件是不会增加到html标签节点上的, 所以要单独在Header内部写个div然后设置样式

```jsx
<Header>
	<div className="header-inner">
	{/* 省略... */}
	</div>
</Header>
// 设置header整体的布局样式
<style jsx>{`
    .header-inner {
        display: flex;
        justify-content: space-between;
    }
    .header-left {
        display: flex;
        justify-content: flex-start;
    }
`}
</style>
{/* 全局样式设置, content内部不够会被挤压的解决样式, 让外层的id和layout的类的height为100% */}
<style jsx global>{`
    #__next, .ant-layout {
    	height: 100%;
    }
`}
</style>
```

- 设置图标GITHUB字体样式和footer的样式

```jsx
// header中 github图标Icon的样式,写在外面是这个style永远不会变, 以后组件渲染不用重新定义对象, 
// 保证了每次header组件中使用的组件github样式是同一个对象, 节省内存
const githubIconStyle = {
  color: 'white',
  fontSize: 40,
  display: 'block',
  paddingTop: 10,
  marginRight: 20,
}
const footerStyle = {
  textAlign: 'center'
}

// 组件return
<div>
    <Icon type="github" style={githubIconStyle}></Icon>
</div>
<Footer style={footerStyle} >...</Footer>
```



## 扩展组件

**cloneElement扩展组件可复用性的高级技巧**

1. 削减代码页面标签的数量
2. 代码整洁
3. components/Container组件

- 业务目标
  - 实现Container组件, 让被它包裹的所有组件都能宽度100%, 左右居中, 并设置最大宽度 Container.jsx

```jsx
const style = {
  width: '100%',
  maxWidth: 600,
  marginLeft: 'auto',
  marginRight: 'auto'
}
export default ({ children }) => {
  return <div style={style}>{children}</div>
}
```

- 问题来了, 我们想修改container中的字体为红色, 如下完全可以满足需求, 即给Container容器组件添加一个div, 然后给div添加className, 但是我们希望把Container当作标签, 传递属性的方式修改Container的样式

```jsx
<Content>
	<Container>
    	<div className={content}>
        	{ children }
        </div>
    </Container>
</Content>
<style jsx>{`
	.content {
		color: red;
	}
`}
</style>

```



- Constainer.jsx

```jsx
import { cloneElement } from 'react'

const style = {
  width: '100%',
  maxWidth: 1200,
  marginLeft: 'auto',
  marginRight: 'auto',
  paddingLeft: 20,
  paddingRight: 20
}

/**
 * 1. Constainer组件接收的是一个jsx的标签, 等同于React.createElement('div) 标签类型, 返回的element类型
 * 2. clone传递进来的element类型的"jsx或者组件", 然后使用Container组件的props覆盖clone的element
 * 3. 扩展节点: 对传入的节点(renderer), 增加props属性(如本例增加style), 来新增或覆盖传递进来的节点, 达到扩展组件或节点的目的
 */
export default ({ children, renderer = <div />}) => {
  console.log(renderer);
  const newElement =  cloneElement(renderer, {
    style: Object.assign({}, renderer.props.style, style),  // 合并style, 将用户自定义的style和本组件设置的style进行合并
    children
  })
  console.log(newElement);
  return newElement;
}

```

- 创建一个测试组件, 组件可以接收的参数props有: color, style, children

```jsx
const MyComp = ({ color, style, children }) => <div style={ color, ...style }>
    { children }
</div>
```

- Layout.jsx中使用Container组件,该传递props就传递, color,

```jsx
<Constainer renderer={<Comp color="red" style={{ fontSize: 40 }}>}>
	{ children } 
</Constainer>
```

- 总结

传入一个组件Comp, 这个组件带有自身样式或者特性, 然后clone这个组件或者jsx, cloneElement, 然后封装组件Container有自定义好的样式或者特性, 然后将Comp中的props和Container中的属性进行对象属性合并

- 调整header中antd自带的样式, 对header-inner的样式div增加Container的样式

```jsx
<Header>
    <Container renderer={<div className="header-inner" />}>
        {/* .... */}
    </Container>
</Header>
```

- header的左右padding为50, 去掉, 踩坑: 样式之间不是以逗号分隔的

```jsx
<style jsx global>
	{`
        #__next, .ant-layout {
            height: 100%;
        }
		// 此处不能加"逗号" , 
        .ant-layout-header {
            padding-left: 0!important;
            padding-right: 0!important;
        }
    `}
</style>
```



## 服务端渲染同步用户信息

1. 在next服务端渲染前, 给ctx.req.session 赋值为ctx.session
2. 然后在redux初始化的地方
3. 服务端渲染,初始状态正确, 刷新之后, 状态数据，前端改变的数据和服务端数据不一致的问题解释
4. 后端server不需要提供一个接口, 然后前端请求接口, 后端返回github用户数据, 最后前端再拿到userInfo, 其实是不需要的, github认证以及获取数据可以在next服务端渲染之前, 把ctx.req.session = ctx.session
5. 赋值之后, 在redux初始化的时候, withRedux.js中, getOrCreateStore函数接收initState, 就可以把这个session设置到全局了
6. 再看store.js, 

- 服务端渲染, 通过react代码通过webpack打包生成的js，会放在.next目录下
- 然后server.js启动服务后, 会动态加载打包之后的js,也就是把打包的js当作Nodejs模块，
- 我们就可以认为，服务端渲染的时候，store.js可以认为是nodejs的模块，`export default store`
- 既然认为是nodejs的模块, store.js代码中导出的store对象就是独一份的, 是共享的
- 也就是它**不会**在每次服务端渲染时, 都会生成一份新的store
- 服务端渲染，store.js在被加载的时候, 已经被生成好了, 服务器在启动之后并不是每次都要重启服务器
- 那么在服务器启动之后, 服务端渲染就都使用同一个store对象
- 这就导致了，状态改变了，是不会进行重置的，默认初始状态是0



## 获取用户信息

代码 server.js中, 所有请求的中间件中, 设置ctx.req.session = ctx.session

> ctx.session其实做了两件事
>
> 通过koa-session这个包对ctx增加了session属性
>
> 通过auth(server)  通过判断路径为/auth进行鉴权时, 满足登录条件的,把userInfo用户信息设置到ctx.session的属性上 如，ctx.session.userInfo

```js
server.use(async (ctx, next) => {
    ctx.req.session = ctx.session
    await handle(ctx.req, ctx.res)	// 服务端返回数据给客户端
    ctx.respond = false
})
```

- 我们希望的是, 在应用初始化的时候, 就把用户的session设置进来

比如, withRedux(MyApp), 在withRedux中, 服务端初始化时(WithRedux.getInitialProps = fn)中，创建store, {getOrCreateStore(服务端初始化用到的参数)}，比如这个参数由user信息。

如何设置的initialState呢? 核心代码是

```js
if (isServer) {
      // 解构的req可能是不存在的,只有在服务端渲染的时候才会存在, 前端切换路由也会执行getInitialProps
      const { req } = ctx.ctx
      const session = req.session
      if (session && session.userInfo) {
    	reduxStore = getOrCreateStore({
          user: session.userInfo
        })
      } else {
 		 reduxStore = getOrCreateStore()       
      }
    
}
```

```js
WithRedux.getInitialProps = async (ctx) => {
    let reduxStore
    if (isServer) {
      // 解构的req可能是不存在的,只有在服务端渲染的时候才会存在, 前端切换路由也会执行getInitialProps
      const { req } = ctx.ctx
      const session = req.session
      // if (session && session.userInfo) {
      if (true) {	// 因为没有登录,测试是否可以设置initialState
        reduxStore = getOrCreateStore({
          user: {
            username: 'sanfeng',
            age: 18
          }
        })
      } else {
        reduxStore = getOrCreateStore()
      }
    } else {
      reduxStore = getOrCreateStore()
    }

  }
  return WithRedux
```

- 点击登录或者右上角的图标进行登录授权

```jsx
<a href={publicRuntimeConfig.OAUTH_URL}>
    <Avatar size={40} icon="user" />
</a>
```

- 然后把登录的userInfo展现到页面上
  - 拿到store中的数据 import { connect } from 'react-redux'
  - 判断是否有用户数据, 有就显示img, 没有就显示默认图标Avatar

```jsx
const mapStateToProps = state => {
    return {
        user: state.user
    }
}
export default connect(mapStateToProps)(MyLayout)
```

```jsx
// 判断组件是否有user, 通过_app.js中的
import App from 'next/app'
import { Provider } from 'react-redux'
import Layout from '../components/Layout'
import withRedux from './store/store'
class MyAPP extends A {
    static async getInitialProps (ctx) {
        const { Component } = ctx
        let pageProps = {}
        if (Component.getInitialProps) {
            pageProps = await Component.getInitialProps(ctx)
        }
        return {
            pageProps
        }
    }
    render () {
        const { Component, pageProps, reduxStore } = this.props
        return (
        	<Provider store={reduxStore}>
            	<Layout>
                	<Component pageProps = {pageProps}/>
                </Layout>
            </Provider>
        )
    }
}
```

```jsx
import {Layout, DropDown, Menu, Tooltip } from 'antd'
import getConfig from 'next/config'
const { publicRuntimeConfig } = getConfig()

const userDropdown = (
	<Menu>
    	<Menu.Item>
        	<a href="javascript:void(0)">注 销</a>
        </Menu.Item>
    </Menu>
)

const MyLayout = ({ children, user }) => {
    return (
        {/* 省略其他内容*/}
        <div className="user">
            {
                user && user.id ? (
                    <Tooltip overlay={userDropdown}>
                        <a href="/">
                            <Avatar size={40} src={user.avatar_url}/>    
                        </a>
                    </Tooltip>
                ) : (
                	<Tooltip title="请点击登录">
                        <a href={publicRuntimeConfig.OAUTH_URL}>
                        	<Avatar size={40} icon="user"/>
                        </a>
                    </Tooltip>
                )
            }
        </div>
    )
}
```



## 注销

1. 鼠标悬停头像图标，出现tooltip，点击注销

2. 始终操作的是store中的user状态数据

3. 注销元素上Menu.Item上绑定一个事件, 然后出发action, 在action中触发ajax请求, 然后修改state，因为user的信息是保存在store中的，一旦页面上注销登录之后

   >1. 服务端清空session
   >2. 页面上这个用户信息也要被清空
   >3. 所以退出登录的整个流程都要围绕着store进行

**代码**



```jsx
const MyLayout = ({ children, user }) => {
    const userDropDown = (
    	<Menu>
        	<Menu.Item>
            	<a href="javascript:void(0)" onClick={handleLogout}>
            </Menu.Item>
        </Menu>
    )
    render () {
        
    }
}
```

```jsx
import { connect } from 'react-redux'
import { logout } from '../store/store'
const MyLayout = ({ children, user, logout }) => {
    const handleLogout = useCallback(
    	() => { logout() },  // 调用actionCreators触发actions
        []
    )
    const userDropDown = (
    	/* ... */
    )
}
const mapStateToProps = state => {
    return {
        user: state.user
    }
}
// 定义action与组件内props的映射关系, 这样MyLayout组件可以通过props(入参)获得,组件内即可引用到
const mapActionToProps = dispatch => {
  return {
    logout: () => dispatch(logout())
  }
}
// 想在MyLayout中使用store中的actionscreators，需要connect把store引入进来
export default connect(mapStateToProps,mapActionToProps)(MyLayout)
```

store.js

```js
// actionCreators: 函数返回一个函数, 参数带上dispatch
import axios from 'axios'

// ACTION-TYPE
const LOGOUT = 'LOGOUT'

// 注销: 发送ajax请求, 
export function logout () {
    return dispatch => {
        axios.post('/logout').then(res => {
            if (res.status === 200) {
				dispatch({
                    LOGOUT
                })
            } else {
                console.log('logout failed: ', res)
            }
    	}).catch(err => console.log("err: ", err))
    }
}

// 发送action之后, 对state进行处理 ---> reducer
const userReducer = (state = userInitialState, action) {
    switch (action.type) {
        case LOGOUT:
            return {}		// 清空userInitialState store中清空用户数据 用户状态的所有属性
        default:
            return state
    }
}
```

以上把所有页面端的逻辑写完了, 因为action要触发axios请求, 请求的服务端接口 axios.post('/logout')还没有处理,需要将server端的session进行清空

---------

auth.js中处理了用户的登录, 也一个中间件或者在同一个server.use中写logout的逻辑即可

```js
server.use(async (ctx, next) => {
    if (ctx.path === 'logout' && ctx.method === 'POST') {
        ctx.session = null
        ctx.body = `logout success`
    } else {
        await next()
    }
})
```



## 登录跳转回原路径

> 我们希望的是, 之前在某个路径页面访问,然后需要点击登录, 登录成功后希望还是原来访问的页面而不是跳转回根路径，在auth.js中登录成功(session设置)，ctx.redirect指向原来的路径

1. 路由中间件处理一个路径prepare_auth,获取原来的路径
2. 在点击登录头像时,记录这个url

### 复杂写法

```js
// 处理登录成功跳转回原来的页面
server.use(async (ctx, next) => {
    if (ctx.path === '/prepare-auth' && ctx.method === 'GET') {
      // 在登录请求之前记录的url
      const { url } = ctx.query
      ctx.session.urlBeforeOAuth = url
      // 比如加上ctx.body = {...},以为如果不加, /prepare-auth?url=/details 这个请求resp就是404
      ctx.body = {}
    } else {
      await next()
    }
})
```

- 然后调用一下接口 /prepare_auth， 在Layout.jsx中点击登录的地方

```jsx
{
    // user通过react-redux的connect获取, 通过MyLayout的props进行传递
    user && user.id ?
        (
        <Dropdown overlay={userDropDown}>
            <a href="/">
                <Avatar size={40} src={user.avatar_url} />
            </a>
        </Dropdown>
    ) : (
        <Tooltip title="点击进行登录">
            <a href={publicRuntimeConfig.OAUTH_URL} onClick={handleGoToOAuth}>
                <Avatar size={40} icon="user" />
            </a>
        </Tooltip>
    )
}
```

```jsx
// 发送接口请求, prepare-auth, 把url传递给后端server的中间件, 然后登录成功后redirect
const handleGoToOAuth = useCallback((e) => {
    // 阻止a标签的默认行为
    e.preventDefault()
    // 这个请求的唯一目的是请求后端接口prepare-auth, 通过query的形式把url传递保存起来,然后端进行跳转redirect,
    // 前端依然去做登录认证的事OAUTH_URL
    axios.get(`/prepare-auth?url=${publicRuntimeConfig.OAUTH_URL}`)
    	.then(resp => {
        if (resp.status === 200) {
            location.href = `${publicRuntimeConfig.OAUTH_URL}`
        } else {
            console.log('login failed ', resp)
        }
    }).catch(err => console.log(err))
}, [])
```



### 简便写法

- 点击登录的a标签的url直接是后端请求的接口路径 /prepare-auth?url=${...}, 其实都是get请求
- 并且也不用写onClick事件去单独再发起axios的get请求
- 请求直接交给a标签的href默认行为处理即可
- 然后接口处理中, 把之前的url记录下来之后, ctx.redirect到github oauth进行认证登录
- 由于在server.js中想获取github的请求地址，如果想通过next/config的getConfig是拿不到的,nextjs是前端的包, 所以需要把配置信息从next.config.js中移动到config.js中



- 在a连接的href中直接写auth.js中的中间件处理登陆前的url的处理逻辑

```jsx
<Tooltip title="点击进行登录">
    <a href={`/prepare-auth?url=${router.asPath}`} >
        <Avatar size={40} icon="user" />
    </a>
</Tooltip>
```

- 中间件处理, 区别是 记录下url之后，后端redirect到github的登录授权请求路径

```js
// 处理登录成功跳转回原来的页面
  server.use(async (ctx, next) => {
    if (ctx.path === '/prepare-auth' && ctx.method === 'GET') {
      // 在登录请求之前记录的url
      const { url } = ctx.query
      ctx.session.urlBeforeOAuth = url
      ctx.redirect(config.OAUTH_URL)
    } else {
      await next()
    }
  })
```

- 因为github的登录需要client_id, GITHUB_OAUTH_URL='https://github.com/login/oauth/authorize'，这些信息之前在next.config.js中设置的, 在server.js后端代码中无法获取next/config，所以需要把之前的在next.config.js中的配置信息放置到config.js中，可以将next.config.js中的相关配置删除

```js
const GITHUB_OAUTH_URL = 'https://github.com/login/oauth/authorize'
const SCOPE = 'user'
const client_id = '26dbc07f67038c430e72'

module.exports = {
  github: {
    client_id,
    client_secret: '627fadc84e8e96ba4819458311557b98c4d6ffe4',
    request_token_url: 'https://github.com/login/oauth/access_token'
  },
  GITHUB_OAUTH_URL,
  OAUTH_URL: `${GITHUB_OAUTH_URL}?client_id=${client_id}&scope=${SCOPE}`
}
```





## 全局页面切换的Loading效果

1. 一个loading组件
2. _app.js中的生命周期方法中, 监听路由的切换的事件，定义函数的处理函数，返回loading组件

- PageLoading.jsx

```jsx
import { Spin } from 'antd'

const pageLoading = () => {
  return (
    <div className="root">
      <Spin />
      <style jsx>
        {`
          .root {
            position: fixed;
            z-index: 100;
            left: 0;
            right: 0;
            top: 0;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: rgba(255, 255, 255, 0.5);
          }
        `}
      </style>
    </div>
  )
}

export default pageLoading
```

- _app.jsx中设置显示隐藏的状态, 通过生命周期函数, 通过路由的生命周期, 监听路由的routeChangeStart,routeChangeComplete,routeChangeError事件, 执行对状态的修改, this.state.isLoading,在render函数中, 通过判断isLoading是否为true, 在Layout组件中判断是否加入PageLoading组件

```jsx
class MyApp extends App {
  constructor(props) {
    super(props)
    this.state = {
      isLoading: false
    }
  }

  startLoading = () => {
    this.setState({
      isLoading: true
    })
  }

  stopLoading = () => {
    this.setState({
      isLoading: false
    })
  }

  componentDidMount() {
    Router.events.on('routeChangeStart', this.startLoading)
    Router.events.on('routeChangeComplete', this.stopLoading)
    Router.events.on('routeChangeError', this.stopLoading)
  }
  componentWillUnmount() {
    Router.events.off('routeChangeStart', this.startLoading)
    Router.events.off('routeChangeComplete', this.stopLoading)
    Router.events.off('routeChangeError', this.stopLoading)
  }

  render () {
      return (
      	<Provider store={reduxStore}>
          {
            this.state.isLoading ? <PageLoading /> : null
          }
          <Layout>
            {/* 添加链接用于链接跳转，触发执行生命周期方法，组件生命周期方法会触发路由的生命周期方法，路由开始，路由结束，路由出错等事件，然后绑定两个不同的函数startLoading和stopLoading函数, 函数用于修改isLoading的状态 */}
            <Link href="/">
              <a>Index</a>
            </Link>
            <Link href='/detail'>
              <a>detail</a>
            </Link>
            <Component pageProps={pageProps} />
          </Layout>
        </Provider>
      )
  }
}

```



## Github接口代理

> 1. github的接口访问是有限制的, 没有登录的是60次每小时, 所有用户的请求次数汇总才60次, 登录是5000次/小时, 并且是每个用户5000次
>
> 2. 如果在全局中请求github的api接口(_app.js), 完全可以在componentDidMount中发起axios的get请求, 很多github的api请求是必须要带上token进行请求的，否则有些是无法获取用户相关的数据的，比如关注的仓库。最好的方式是，把api的请求发送到我们自己的服务(server.js 或者一个koa的中间件)，然后在我们的服务中代理到github，然后在koa的处理中，再根据用户的状态是否为登录，传入token
>
> 3. 那么为什么不把token返回给前端页面上，然后在前端页面带上这个token，发送axios请求到github上呢?
>
>    1. 因为token是十分敏感的信息，不应该暴露给外网，不应该存储在客户端，存储在客户端在发送请求的时候有可能被黑客拦截，获取token，然后返回一些用户数据被利用
>
>    2. 前端不代理github请求的方式
>
>       `axios.get('https://api.github.com/search/repositories?q=react').then(res => {  	console.log(res) })`
>
>    3. github接口请求代理到本地的后端服务
>
>       `axios.get('/github/search/repositories?q=react').then(...)`



- api.js

```js
const github_base_url = 'https://api.github.com'
const axios = require('axios')

module.exports = server => {
  server.use(async (ctx, next) => {
    const path = ctx.path
    if (path.startsWith('/github/')) {
      const githubAuth = ctx.session.githubAuth
      const githuPath = `${github_base_url}${ctx.url.replace('/github/', '/')}`
      // 获取token
      const token = githubAuth && githubAuth.access_token
      let headers = {}
      // 判断是否有token
      if (token) {
        headers['Authorization'] = `${githubAuth.token_type} ${token}`
      }
      try {
        let result = await axios({
          method: 'GET',
          url: githuPath,
          headers
        })
        if (result.status === 200) {
          ctx.set('Content-Type', 'application/json')
          ctx.body = result.data
        } else {
          ctx.set('Content-Type', 'application/json')
          ctx.body = {
            success: false,
            msg: 'axios status is not 200'
          }
        }
      } catch (error) {
        console.log("error: ", error)
        ctx.set('Content-Type', 'application/json')
        ctx.body = {
          success: false
        }
      }
    } else {
      await next()
    }
  })
}

```

- server.js中引入 并使用中间件

```js
// ...
const api = require('./server/api')
auth(server)
api(server)
```



## 完善整体布局

- ant-layout-content这个css类antd提供的, 是个flex布局, 没有设置height, 如果包裹的元素的高度超过了页面高度, 中间的content就会超出content, 并且超过footer, 测试: 给main下的div设置height为1000px

```css
.ant-layout {
    # height: 100%; # 修改前
    min-height: 100%;
}
```

- ant-layout-content 增加背景

```jsx
.ant-layout-content {
	background: #fff;
}
```

- 增加logo图标点击, 跳转到主页 /

```jsx
import Link from 'next/link'
<Link href="/">
    <Icon type="github" style={githubIconStyle} />
</Link>
```

- 完善搜索功能

1. antd中的 Input.Search中定义的事件 onSearch绑定的函数 handleOnSearch(自定义的) 使用useCallback

```jsx
const MyLayout = ({ children, user, logout, router }) => {
    const [SearchText, setSearchText] = useState('')
    const handleOnSearch = useCallback(
        () => {
        	router.push(`/search?query=${SearchText}`)
    	}, [SearchText])
    
    
    return (
    	<div>
        	<Input.Search 
            	value = { SearchText }
                onChange = { handleSearchTextChange }
                onSearch = { handleOnSearch }
            />
        </div>
    )
}
```

2. pages/search.js

> 1. 在search页面中拿到搜索查询信息, SearchText

```jsx
const Search = ({ router }) => {
    return (
    	<span>{ router.query.query }</span>
    )
}
export default Search;
```

3. 晚上Layout 刷新之后, url依然是查询url，比如 http://localhost:3000/search?query=react 但是查询框为空

```jsx
const MyLayout = ({ children, user, logout, router }) => {
    // router.query && router.query.query 避免报错，
    // 如果router.query不存在直接使用router.query.query就会报错
	const urlQuery = router.query && router.query.query
    const [SearchText, setSearchText] = useState(urlQuery || '')
}
```



## Github接口代理完善

### next请求接口就会发生的问题

> 问题描述
>
> **正常情况下, Index页面的服务端请求**
>
> ```jsx
> Index.getInitialProps = async (ctx) => {
>   const result = await Axios
>     .get('/github/search/repositories?q=react')
>     .then(res => console.log(res))
> 
>   return {
>     data: result.data
>   }
> }
> ```
>
> 刷新页面会出现如下错误
>
> ```
> connect ECONNREFUSED 127.0.0.1:80
> Error: connect ECONNREFUSED 127.0.0.1:80
>     at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1106:14)
> ```
>
> **原因是什么?**
>
> 1. axios在**浏览器环境下**发送请求, 请求地址会自动加上网站的域名，也就是http://localhost:3000，然后再加上axios请求的url，那么完整的请求url是: http://localhost:3000/github/search/repositories?q=react
> 2. axios在服务端渲染进行执行, 是没有浏览器的域名的一个场景的, axios在服务端自动增加的就是http://127.0.0.1/github/search/repositories?q=react, 而且也没有加端口号，就是80端口，所以这个服务端的请求发送到了本地的80端口，本地也没有启动80，实际启动的是3000，并且这个请求地址也不是我们期望的请求地址
>
> **如何解决?**
>
> 1. 客户端和服务端的请求要单独分开进行处理, 也就是同构前后端的axios的请求
>
> 2. 然后在组件调用getInitialProps的时候, 无论是客户端调用还是服务端渲染, 统一调用(/lib/api.js)处理后的对外敞开的接口request({}, req, res), 





- 每个页面（组件）的getInitialProps的执行

1. 客户端每个页面跳转时会执行
2. 服务端渲染时,也会执行组件的getInitialProps

- 页面跳转处于**浏览器环境**，服务端渲染执行，处于**nodejs环境**, 

- 服务端发起axios请求时, url请求地址就不会有浏览器才有的domain，

  - 如果服务端请求的是

  ```js
  axios.get('/github/search/repositories?q=react')
  ```

  - nodejs会直接请求的是, 域名就是自己的本地, 端口是80

  ```js
  axios.get('http://localhost/github/search/repositories?q=react')
  ```

- 提取一个公共的api接口, 用来判断是否为服务端渲染 /lib/api.js

### 1. 同构客户端与服务端请求

- 封装一个api.js，用户处理getInitialProps中涉及到的客户端调用还是服务端调用
  - 服务端请求: 从session中拿到token,拼接headers, 以及github的完整的url
  - 客户端请求: 只处理url, 因为请求发送给koa后端中间件, koa对请求接口前缀为/github/进行拦截, 然后处理前端发送的url为github标准的url( 替换 /github/为/), 然后发送请求

#### lib/api.js同构请求

```js
/**
 * 主要用于处理每个组件中的getInitialProps请求接口的函数, 也就是这个文件既要在客户端也要在服务端执行
 * 我们不能使用export语法,nodejs还不支持export
 */
const axios = require('axios')

const github_base_url = 'https://api.github.com'

// 请求github的数据
/**
 * 
 * @param {*} method 
 * @param {*} url 
 * @param {*} data 
 * @param {*} headers 
 */
async function requestGithub (method, url, data, headers) {
  return await axios({
    method,
    url: `${github_base_url}${url}`,    // 拼接github请求的真正的url, 带上域名
    data,
    headers
  })
}

const isServer = typeof window === 'undefined'

/**
 * 这个函数就要区别 客户端请求 还是 服务端请求 自动添加域名的处理
 * 服务端渲染添加本地80端口的域名 http://127.0.0.1/github/...
 * 客户端添加网站域名 http://localhost:3000/github/...
 * @param {} 传递给axios的配置参数, 也就是请求参数 
 * @param {*} req 
 * @param {*} res 
 */
async function request ({ method = 'GET', url, data = {} }, req, res) {
  if (!url) {
    throw Error('url must provide')
  }
  if (isServer) {
    // 如果是服务端渲染, 直接创建请求，请求github的数据
    // 1. 从session中获取access_token
    // 2. 把token拼接到headers上发起请求
    const session = req.session
    const githubAuth = session.githubAuth || {}
    let headers = {}
    if (githubAuth.access_token) {
      headers['Authorization'] = `${githubAuth.token_type} ${githubAuth.access_token}`
    }
    console.log('服务端渲染调用...')
    return await requestGithub(method, url, data, headers)
  } else {
    // 客户端请求, 需要加上/github的开发者约定的前缀, 以便koa中间件代理github请求时, 后端可以对这类特殊请求进行处理
    // 此处为什么不用传递headers? 因为headers是请求到api地址之后,从session里拿到token,然后拼接组合成headers
    console.log('客户端调用...')
    return await axios({
      method,
      url: `/github${url}`,
      data
    })
  }
}

module.exports = {
  request,
  requestGithub
}
```

#### server/api.js处理客户端请求

```js
const { requestGithub } = require('../lib/api')
// koa的中间件服务, 用于处理客户端发起的axios请求
// 从session中获取token, 拼接headers, 发送到github请求数据
module.exports = server => {
  server.use(async (ctx, next) => {
    const path = ctx.path
    const method = ctx.method
    if (path.startsWith('/github/')) {
      // 处理headers
      const session = ctx.session
      const githubAuth = session && session.githubAuth
      const headers = {}
      if (githubAuth && githubAuth.access_token) {
        headers['Authorization'] = `${githubAuth.token_type} ${githubAuth.access_token}`
      }
      // github实际的api可能是 /search/repositoies?q=react, koa做一次代理, 就要给添加一个标志标明是接口请求
      // 所以加上github, 但是实际向github发请求时, 要先将自定义的前缀去掉,ctx.url.replace('/github/', '/')
      // 这样github开放的api接口才是可以请求的
      const result = await requestGithub(
        method,
        ctx.url.replace('/github/', '/'),   
        {},
        headers
      )
      // 把github返回给自己的server原封不动的返回给客户端 status data
      ctx.status = result.status
      ctx.body = result.data
    } else {
      await next()
    }
  })
}

```

#### Index.jsx调用

- 初始化服务端渲染调用getInitialProps
- 页面跳转客户端调用getInitialProps

```jsx
Index.getInitialProps = async ({ ctx }) => {
  // const result = await Axios
  //   .get('/github/search/repositories?q=react')
  //   .then(res => console.log(res))
  // 组件中只需要用request, 因为这个函数已经处理了是客户端还是服务端发起的请求
  const result = await api.request(
    {
      url: '/search/repositories?q=react'
    }, 
    // 只会在服务端渲染的时候才会使用req, 从req中拿到session
    ctx.req, 
    ctx.res
  )
  return {
    data: result.data
  }
}

```

### 2. 处理post请求

```
yarn add koa-better-body
```

server.js

```js
const body = require('koa-better-body')

// 中间件将post请求的数据挂载到ctx.request.fields上
app.prepare().then(() => {
    server.use(body({
        uploadDir: path.resolve(__dirname, './static/upload')
      }))
    }
)

// server/api.js
const result = await requestGithub(
    method,
    ctx.url.replace('/github/', '/'),   
    ctx.request.fields || {},
    headers
)
```

客户端组件模拟一个post请求

index.jsx

```jsx
import { useEffect } from 'react'
import axios from 'axios'
const Index = () => {
    useEffect(() => {
        axios.post('/github/test', { username: 'sanfeng'})
    })
    return (
    	<div>
        	index
        </div>
    )
}
```



## 联调首页数据请求

### 1. 服务端请求数据

- index.jsx中服务端渲染请求github的数据

> 入坑: pages下的组件, getInitialProps方法的return值都可以被当前组件通过props获取到
>
> const { userRepos, userStarredRepos } = this.props
>
> 因为在_app.js中, 对所有Component组件(即所有pages下的每个js文件)的getInitialProps静态方法做了处理，其中, static 的方法返回的pageProps, 传递给Compnent要进行结构{...pageProps},而不是pageProps={pageProps}
>
> ```jsx
> import App from 'next/app'
> import { Provider } from 'react-redux'
> import withRedux from '../lib/withRedux'
> class MyApp extends App {
>     static async getInitialProps (ctx) {
>         const { Component } = ctx;
>         let pageProps = {}
>         if (Component.getInitialProps) {
>             pageProps = await Component.getInitialProps(ctx)
>         }
>         return {
>            pageProps 
>         }
>     }
>     render () {
>         const { Component, pageProps, reduxStore } = this.props
>         return (
>         	<>
>             	<Provider store = { reduxStore }>
>                 	<Layout>
>                 		<Component { ...pageProps } />
>                 	</Layout>
>             	</Provider>
>             </>
>         )
>     }
> }
> export default withRedux(MyApp)
> ```
>
> 

```jsx
const api = require('../lib/api')
const Index = ({userRepos, userStarredRepos}) => {
    return <div>Index</div>
}
Index.getInitialProps = async ({ ctx }) => {
    const userRepos = await api.request({
        url: '/user/repos'
    }, ctx.req, ctx.res)
    const userStarredRepos = await api.request({
        url: '/user/starred'
    }, ctx.req, ctx.res)
    return {
        userRepos: userRepos.data,
        userStarredRepos: userStarredRepos.data
    }
}
export default Index
```



### 2. 退出登录刷新页面401错误

因为已经退出登录, 刷新页面, 首页就是401，未授权，直接报错，未登录状态就无法获取到user相关的信息了

1. 我们可以通过ctx.req.session来判断用户的状态, 是否有user, 或者user.id, 但是这个只能在服务端可以，客户端是不行的，因为客户端在页面切换的时候, ctx上是没有req，res的，这两个对象是nodejs环境的，不存在浏览器的环境下

2. 我们可以使用store中保存的用户信息

   1. 在withRedux.js中, 把store保存到了ctx上

   ```js
   WithRedux.getInitialProps = async (ctx) => {
       let reduxStore
       if (isServer) {
         // 解构的req可能是不存在的,只有在服务端渲染的时候才会存在, 前端切换路由也会执行getInitialProps
         const { req } = ctx.ctx
         const session = req.session
         if (session && session.userInfo) {
           reduxStore = getOrCreateStore({
             user: session.userInfo
           })
         } else {
           reduxStore = getOrCreateStore()
         }
       } else {
         reduxStore = getOrCreateStore()
       }
       // 重点在这里重点在这里重点在这里重点在这里重点在这里重点在这里
       ctx.reduxStore = reduxStore
       // 重点在这里重点在这里重点在这里重点在这里重点在这里重点在这里
       let appProps = {}
       if (typeof Comp.getInitialProps === 'function') {
         appProps = await Comp.getInitialProps(ctx)
       }
       return {
         ...appProps,
         initialReduxState: reduxStore.getState()
       }
     }
   ```

   2. index.jsx

   ```jsx
   Index.getInitialProps = async ({ ctx, reduxStore }) => {
     const user = reduxStore.getState().user
     if (!user || !user.id) {
       return {
         isLogin: false
       }
     }
     // ....
   }
   ```

   3. 但是如果如果点击退出登录之后, 页面依然没有通过判断isLogin来重新渲染页面，没有显示"亲，您还没有登录"

   ```jsx
   function Index({ userRepos, userStarredRepos, isLogin }) {
     // 不能使用传入的isLogin, 要使用store中的, store中的数据发生变化, 会触发组件的重新渲染
     if (!isLogin) {
       return <div className="root">
         <p>亲，您还没有登录</p>
         <Button type="primary" href={config.OAUTH_URL} >点击登录</Button>
         <style jsx>
           {`
             .root {
               height: 400px;
               display: flex;
               flex-direction: column;
               justify-content: center;
               align-items: center;
             }
           `}
         </style>
       </div>
     }
     return <div>Index</div>
   }
   Index.getInitialProps = async ({ ctx, reduxStore }) => {
     const user = reduxStore.getState().user
     if (!user || !user.id) {
       return {
         isLogin: false
       }
     }
     return {
       isLogin: true, //
       userRepos: userRepos.data,
       userStarredRepos: userStarredRepos.data,
     }
   }
   ```

   4. 这是因为getInitialProps存在的局限性，**这个函数在页面进入的瞬间会被调用**，但是登出的操作只是改变了store的状态，并**没有重新刷新页面**，**也没有从别的页面跳转进来**, 所以没有再次调用getInitialProps, 也就不会返回isLogin的最新状态false, 点击登录后, 用户状态是未登录,因为getInitialProps没有执行, isLogin还是true, 所以"亲，您还没有登录"就无法显示了
   5. 如何解决? 使用connect连接store中的状态
   
   ```jsx
   Index.getInitialProps = async ({ ctx, reduxStore }) => {
     const user = reduxStore.getState().user
     if (!user || !user.id) {
       return {
         isLogin: false
       }
     }
     return {
       isLogin: true, //
       userRepos: userRepos.data,
       userStarredRepos: userStarredRepos.data,
     }
   }
   const mapState = state => {
       return {
           user: state.user
       }
   }
   export default connect(mapState)(Index)
   ```
   
   

## Repo组件展示基本组件内容

- 通过Index中的服务端渲染getInitialProps请求数据, return { userRepos: result.data }, 组件通过props获取
- userRepos是数组,直接userRepos.map(repo => <Repo repo={repo}>) 遍历结果数据
- 仓库更新时间格式处理moment

### 抽离组件Repo.js

```jsx
import Link from 'next/link'
import { Icon } from 'antd'
import moment from 'moment'

function getLicense (license) {
  return license ? `${license.spdx_id} license` : ''
}
function getLastUpdated (time) {
  return moment(time).fromNow()
}

export default ({ repo }) => {
  return (
    <div className="root">
      <div className="basic-info">
        <h3 className="repo-title">
          <Link href={`/detail?owner=${repo.owner.login}&name=${repo.name}`}>
            <a>{repo.full_name}</a>
          </Link>
        </h3>
        <p className="repo-desc">{repo.description}</p>
        <p className="other-info">
          {
            // other-info中, 如果没有license没有, span在页面上会多出一个空格,需要进行判断
            repo.license ? <span className="license">{getLicense(repo.license)}</span> 
                : null
          }
          <span className="last-updated">{getLastUpdated(repo.updated_at)}</span>
          <span className="open-issues">{repo.open_issues_count} open issues</span>
        </p>
      </div>
      <div className="lang-star">
        <span className="lang">{repo.language}</span>
        <span className="stars">
          { repo.stargazers_count } <Icon type="star" theme="filled"/>
        </span>
      </div>
      <style jsx>
      {`
        .root {
          display: flex;
          justify-content: space-between;
        }
        .other-info > span + span {
          margin-left: 10px;
        }
        .root + .root {
          border-top: 1px solid #eee;
          padding-top: 20px;
        }
        .repo-title {
          font-size: 20px;
        }
        .lang-star {
          display: flex;
        }
        .lang-star > span {
          width: 120px;
          text-align: right;
        }
        .repo-desc {
          width: 400px;
        }
      `}
      </style>
    </div>
  )
}
```



### flex布局知识点复习

- 给父容器添加flex布局

```css
.box {
    # 给父容器添加flex布局
    display: flex;
    # 容器的主轴对齐
    justify-content: center | flex-start | flex-end | space-between | space-around;
    # 副轴(交叉轴)对齐方式
    align-items: flex-start | flex-end | center | baseline | stretch;
}
```

- 容器中的item的属性

```css

```



## Tabs切换不同主题的repos

在index.jsx中, 设置不同的Tabs, 自己的repos和你关注的repos

```jsx
<div className="user-repos">
	<Tabs defaultActivityKey = "1">
        <Tabs.TabPane tab="你的仓库" key="1">
        	{ userRepos.map(repo => (<Repo repo = { repo }/>))}
        </Tabs.TabPane>
        <Tabs.TabPane tab="你关注的仓库" key="2">
        	{ userStarredRepos.map(repo => (<Repo repo = { repo } />))}
        </Tabs.TabPane>
    </Tabs>
</div>
```

- 存在的问题

  - 当点击的不是默认的repo, 比如key=2的repo, 然后再访问detail页面, 然后再跳转回Index后
    - 回到Index显示的是默认的repo，key=1的信息, 我们希望是返回key=2的你关注的仓库
    - 数据会重新加载 (缓存数据, 非redux的方式, 因为redux是保存公共全局性的数据,保存多个页面的数据)

- 如何解决以上两个问题

  - 把两个tab的属性作为url的query参数保存起来
    - 使用路由 `import { withRouter } from 'next/router'`
    - export default connect(...)(wtihRouter(Index)), 包裹Index, 让组件有router对象
    - 通过router的query拿到key。`const tabKey = router.query.tabKey || '1'`
    - 然后让这个tabKey作为Tab中的activeKey, `<Tabs activeKey={tabKey}></Tabs>`
    - 然后处理Tabs的onChange事件,然后把当前激活的key保存在router的query上

  ```jsx
  const tabKey = router.query.key || '1'
  const handleTabChange = (selectKey) => {
      // 将当前的Tab的key设置到路由上, 点击某个tab, 就会路由设置为http://localhost:3000/?query=1,2,3...
      // 路由是history的, 当你访问/detail之后再回退时, url的路径就是http://localhost:3000/?query=2
      // 此时访问的是Index, 由detail跳转回Index, 所以程序从上向下执行, 就会获取tabKey
      Router.push(`/?key=${selectKey}`)
    }
  
  <Tabs activeKey={tabKey} onChange={ handleTabChange } >
      <Tabs.TabPane tab="你的仓库" key="1">
          {userRepos.map(repo => (
              <Repo repo={repo} />
          ))}
      </Tabs.TabPane>
      <Tabs.TabPane tab="你关注的仓库" key="2">
          {userStarredRepos.map(repo => (
              <Repo repo = {repo} />
          ))}
      </Tabs.TabPane>
  </Tabs>
  ```




## 使用缓存数据

> 当使用Tab切换不同的数据的时候, 每一次切换tab, 都会重新请求一次数据，而正常情况下，"我的仓库"和"我关注的仓库"不是经常变化的。其实, 我们在第一次获取页面数据的时候, 是可以将数据进行复用的
>
> 1. 使用一种非redux的实现方式，自己实现基本原理 (逐步细说问题)



```js
// 全局模块中定义缓存的数据变量
let cachedUserRepos, cachedUserStarredRepos

// 请求接口前, 看看是否有缓存数据, 如果有就直接使用缓存, 没有才请求数据
if (cachedUserRepos && cachedUserStarredRepos) {
    return {
        userRepos: cachedUserRepos,
        userStarredRepos: cachedUserStarredRepos
    }
}

// 在获取完数据之后把数据赋值给定义的缓存数据
// 在组件的getInitialProps中获取数据
const userRepos = await api.request({
    url: '/user/repos',
}, ctx.req, ctx.res)
const userStarredRepos = await api.request({
    url: '/user/starred'
}, ctx.req, ctx.res)
// 向后端请求完数据, 把数据存储在缓存中(保存到一个变量中),然后判断这个变量是否为空, 为空就请求数据, 不为空就直接使用之前请求的数据
cachedUserRepos = userRepos.data;
cachedUserStarredRepos = userStarredRepos.data


```

- 问题bug

> 如果使用无痕浏览的方式, 切换另一个github账号登录, 数据还是原来的仓库信息
>
> 因为服务端渲染, index.jsx模块加载了一次, 数据就初始化了, cachedUserRepos等两个变量是全局变量, 数据就不会改变了. 需要把这两个变量移动一下位置，然后判断一下是否为服务端渲染的情况, 如果是服务端端渲染, 就跳过缓存

```js
const isServer = typeof window === 'undefined'
```





### 使用lru-cache的缓存策略



## 搜索页面

### 1. 版本1

- 从路由中获取数据，把数据渲染到页面中

> 关注的search条件有哪些, 把这些参数放到url,这样可以在浏览器中保存记录, 通过前进后退跳转不同的搜索条件
>
> 1. sort: 排序方式
> 2. order: 排序顺序
> 3. lang: 仓库的项目开发主语言
> 4. page:分页页面
> 5. query

- 首先从Layout.jsx中的查询框的绑定事件开始

```jsx
<Input.Search
     value={SearchText}
     placeholder="input Search text"
     onChange={handleSearchTextChange}
     onSearch={handleOnSearch}
/>

// 搜索框查询事件, 查询结果, 路由跳转到search页面进行展示, 增加search.js
const handleOnSearch = useCallback(
    () => {
        router.push(`/search?query=${SearchText}`)
    }, [SearchText]
)
```

- 拼接路由进行跳转到search页面, 然后调用search页面或组件的getInitialProps函数获取url的查询参数

```js
const MyLayout = ({ router  }) => { // 省略其他参数 如children, user, logout
  const urlQuery = router.query && router.query.query
  const [SearchText, setSearchText] = useState(urlQuery || '')
  const handleSearchTextChange = useCallback(
    e => setSearchText(e.target.value),
    [setSearchText]
  )
  const handleOnSearch = useCallback(
    () => {
        router.push(`/search?query=${SearchText}`)
    }, [SearchText]
  )
}
```

- search组件初始化或者url变更时, 调用getInitialProps进行查询结果的初始化

```jsx
// 根据上面的MyLayout的handleOnSearch的Router.push, 解构出url的query
Search.getInitialProps = ({ ctx }) => {
    // const { query } = ctx.query // 解构出必须的, 因为你必须输入检索词
    // 第一次只是输入了检索词, 肯定只有query, 没有lang,sort等
    const { query, lang, sort, order, page } = ctx.query
    if (!query) {
        return {
            repos: {
                total_count: 0
            }
        }
    }
    // 拼接url
    // ?q=react+language:javascript&sort=stars&order=desc&page=2
    let querystring = `?q=${query}`
    if (lang) querystring += `+language:${lang}`
    if (sort) querystring += `&sort=${sort}&order=${order || 'desc'}`
    if (page) querystring += `&page=${page}`
    const result = await api.request({
        url: `/search/repositories${querystring}`
    }, ctx.req, ctx.res)
    return {
        repos: result.data
    }
}


```



- 页面左侧的搜索条件列表数据

```js
/**
 * 搜索条件，选择了语言, 然后再选择是获得的star最多或者最少,或者获得Fork最多或最少来进行筛选数据
 */
const LANGUAGE = ['javascript', 'HTML', 'CSS', 'Typescript']
const SORT_TYPES = [
  {
    name: 'Best Match' // 默认条件
  },
  {
    name: 'Most Stars',
    value: 'stars',
    order: 'desc'
  },
  {
    name: 'Fewest Stars',
    value: 'stars',
    order: 'asc'
  },
  {
    name: 'Most Forks',
    value: 'forks',
    order: 'desc'
  },
  {
    name: 'Fewest Forks',
    value: 'forks',
    order: 'asc'
  }
]
```

- 根据获取url的query参数, 解构出查询的参数的选项的值, 来拼接querystring

```js
const { lang, sort, order, query } = router.query
```

- 页面结构: 左侧列表, 列表循环每一项查询条件, **点击每一项**, 路由跳转拼接url

```jsx
const { lang, sort, order, query } = router.query
return (
	<div className="root">
    	<Row gutter={20}>
        	<Col span={6}>
            	<List 
                	bordered
                    header={<span className="list-header">语言</span>}
                    style={{ marginBottom: 20 }}
                    dataSource = { LANGUAGE }
                    renderItem = { item => {
                        const selected = item === lang
                        return (
                        	<List.Item style={ selected ? selectedItemStyle : null}>
                            	<a onClick={ () => handleLanguageChange(item) }>
                                    { item }
                                </a>
                            </List.Item>
                        )
                    }}
                />
                <List 
                	bordered
                    header={<span className="list-header">排序</span>}
                    style = {{ marginBottom: 20}}
                    dataSource = { SORT_TYPES }
                    renderItem = { item => {
                        const selected = false
                        if (item.name === 'Best Match' && !sort) {
                            selected = true
                        } else if (item.sort === sort && item.order === order) {
                            selected = true
                        }
                        return (
                        	<List.Item style={ selected ? selectedItemStyle : null}>
                            	<a onClick={ () => { handleSortChange(item)}}>
                                	{ item.name }
                                </a>
                            </List.Item>
                        )
                    }}
                />
            </Col>
        </Row>
    </div>
)
```

- 增加样式, 点击之后列表左侧增加样式

```js
const selectedItemStyle = {
  borderLeft: '2px solid #e36209',
  fontWeight: 100
}
```

- 增加a链接的点击事件, 进行路由跳转, 然后调用上面的Search.getInitialProps, 然后里面解构ctx.query, 拼接github查询的url api

```jsx
import Router from 'next/router'

const { lang, sort, order, query } = router.query
// 语言筛选
const handleLanguageChange = language => {
    Router.push({
        pathname: '/search',
        query: {
            query,
            lang: language,
            sort,
            order
        }
    })
}

const handleSortChange = sort => {
    Router.push({
        pathname: '/search',
        query: {
            query,
            lang,
            sort: sort.value,
            order: sort.order
        }
    })
}
```

### 2. 版本2 优化

1. 路由跳转的代码是十分相似的(handleLanguageChange, handleSortChange), 合并成一个方法 doSearch

```js
// 1. 先整合两个方法，在组件内写
const doSearch = (config) => {
    Router.push({
        pathname: '/search',
        query: config
    })
}
// 2. 再思考,组件内的函数使用useCallback, 但是发现, 这个函数不依赖Search组件内的任何state或props
const doSearch = useCallback(config => {
    Router.push({
        pathname: '/search',
        query: config
    })
}, [])

// 这个方法是个纯粹的方法, 不依赖组件的任何state和props, 所以要提炼出组件外
const doSearch = (config) => {
    Router.push({
        pathname: '/search',
        query: config
    })
}
const Search = ({ router, repos }) => {
    // ...
   return (
        <div className="root">
          <Row gutter={20}>
            <Col span={6}>
              <List
                bordered
                header={<span className="list-header">语言</span>}
                style={{ marginBottom: 20 }}
                dataSource={LANGUAGE}
                renderItem={item => {
                  const selected = item === lang
                  return (<List.Item style={selected ? selectedItemStyle : null}>
                    <a onClick={() => doSearch({
                      query, lang: item, sort, order
                    })}>{item}</a>
                  </List.Item>
                  )
                }}
              />
            </Col>
          </Row>
        </div>
	)
}

// 那么上面这个config从哪里来的呢? 从页面中传递的, 选择点击"语言"的，或者"排序"的, 如下直接传递
<a onClick={() => doSearch({
    query, lang: item, sort, order
})}>{item}</a>

```

2. 合并之后的doSearch, 在把doSearch传递给a标签的onClick，依然要重新声明一个匿名方法的

   onClick={ () => doSearch({query, lang: item, sort, order}) }，每次声明都是一个新的方法，仍然会导致a标签的重新渲染，那么这个a标签的作用是什么? 就是根据url的参数query, lang...以及item这个参数sort,order进行跳转, 那么我们就可以抽象出一个组件来 FilterLink

```jsx
const FilterLink = ({ name, query, lang, sort, order }) => {
    const doSearch = () => {
        Router.push({
            pathname: '/search',
            query: {
                query,
                lang,
                sort,
                order
            }
        })
    }
    return <a onClick={ doSearch }>{ name }</a>
}
```

 

```jsx
// 把之前的a标签替换为FilterLink
<List
    bordered
    header={<span className="list-header">语言</span>}
    style={{ marginBottom: 20 }}
    dataSource={LANGUAGE}
    renderItem={item => {
        const selected = item === lang
        return (<List.Item style={selected ? selectedItemStyle : null}>
          {/* <a onClick={() => doSearch({
          	query, lang: item, sort, order
           })}>{item}</a> */}
            <FilterLink name={item} query={query} lang={item} sort={sort} order={order}/>
          </List.Item>
        )
    }}
/>

```

3. 进一步的优化

- 在Search组件解构router.query时, 解构出来的即通过查询参数都可以当作默认参数, 对于特殊的参数, 在FilterLink中把特殊的参数放到后面

```jsx
const { ...querys } = router.query
const { lang, sort, order } = router.query

// 对于点击语言进行查询, 特殊的参数就是lang, 以及需要显示的列表内容 name
<List.Item>
	<FilterLink {...querys} lang={item} name={item}/>      
</List.Item>

return (
    <List.Item style={selected ? selectedItemStyle : null}>
		<FilterLink { ...querys } name={item.name} sort={item.value} order={item.order}/>
    </List.Item>
)

```

- 当点击Best Match时, url是这样的, http://localhost:3000/search?query=react&lang=&sort=&order=, 其中

sort和order都是空的, 不应该显示

```jsx
const FilterLink = ({ name, query, lang, sort, order }) => {
  // 去掉a标签的onClick事件，在组件内拼接url，使用Link的url
  let querystring = `?query=${query}`
  if (lang) querystring += `&lang=${lang}`
  if (sort) querystring += `&sort=${sort}&order=${order || 'desc'}`

  return (
    <Link href={`/search${querystring}`}>
      <a>{name}</a>
    </Link>
  )
}
```



- 鼠标停在查询条件上, 下面应该显示链接的地址, 可是此时没有显示, 这样会不能使用SEO解析html，进行搜索优化

```jsx
// 同上
```



- 标签选中时还是可以点击的, 实际上是不可以点击的, 加一个是否选中, 选中就显示一个span

```jsx
<List.Item style={selected ? selectedItemStyle : null}>
    {selected ? <span>{item}</span> : 
        <FilterLink
            {...querys}
            name={item}
            lang={item}
            />}
</List.Item>

<List.Item style={selected ? selectedItemStyle : null}>
    {
      selected ? <span>{item.name}</span> :
        <FilterLink {...querys} name={item.name} sort={item.value} order={item.order} />
    }
</List.Item>
```

- 增加一点样式

```jsx
<style jsx>
    {`
    .root {
    	padding: 20px 0;
    }
    .list-header {
        font-weight: 800;
        font-size: 16px;
    }
    `}   
</style>
```

- 优化组件FilterLink, 因为这个组件时纯粹根据props进行更新的, 所以可以使用memo进行优化

```jsx
import { memo } from 'react'
const FilterLink = memo(({ name, query, lang, sort, order }) => {

  let querystring = `?query=${query}`
  if (lang) querystring += `&lang=${lang}`
  if (sort) querystring += `&sort=${sort}&order=${order || 'desc'}`

  return (
    <Link href={`/search${querystring}`}>
      <a>{name}</a>
    </Link>

  )
})
```

### 3. 搜索页面结果页面展示

```jsx
// 所有结果展示, 复用Repo组件
import Repo from '../components/Repo'

{/* 查询结果展示 */}
<Col span={18}>
    <h3 className="repos-title">{repos.total_count}个仓库</h3>
    {
        repos.items.map(repo => <Repo repo = { repo } key = {repo.id} />)
    }
</Col>
<style jsx>{`
	.repos-title {
		font-weight: 800;
		font-size: 20px;
		line-height: 40px;
	}
`}
</style>
```

- 分页

```jsx
import { Row, Col, List, Pagination } from 'antd'

const noop = () => {}
<div className="pagination">
    <Pagination 
        pageSize={30}
        current={ Number(page) || 1}
        total={repos.total_count}
        onChange={noop}
        itemRender={(page, type, ol) => {
            // console.log(page) pagination中的参数page是个标签,需要进行判断
            const p = type === 'page' ? page : type === 'prev' ? page - 1 : page + 1
            const name = type === 'page' ? page : ol
            return <FilterLink {...querys} page = {p} name = {name}/>
        }}
        />
</div>
```



```jsx
const FilterLink = memo(({ name, query, lang, sort, order, page }) => {

  let querystring = `?query=${query}`
  if (lang) querystring += `&lang=${lang}`
  if (sort) querystring += `&sort=${sort}&order=${order || 'desc'}`
  if (page) querystring += `&page=${page}`
  querystring += `&per_page=${per_page}`
  // console.log(isValidElement(name))
  return (
    <Link href={`/search${querystring}`}>
      { isValidElement(name) ? name : <a>{name}</a> }
      {/* <a>{name}</a> */}
    </Link>
  )
})
```

- Search组件中增加参数page

```jsx
const Search = ({ router, repos }) => {
	const { lang, sort, order, page } = router.query
}
```

- 分页样式 居中

```css
.pagination {
    padding: 20px;
    text-align: center;
}
```

pagination,

per_page：每一页显示的记录数



## 仓库详情页

> 思路:
>
> 1. 想布局
> 2. 看布局中使用到的数据, 从组件的getInitialProps中请求后端接口返回结果
> 3. 请求接口会使用一些参数(查询参数,如owner, name), 这些参数从url上下文中获取 ctx.query
>    1. `getInitialProps`入参对象的属性如下：
>       1. `pathname` - URL 的 path 部分
>       2. `query` - URL 的 query 部分，并被解析成对象
>          1. query部分就是?后面的内容, 如 /search?lang=HTML&sort=stars&order=desc中的lang=HTML&sort=stars&order=desc
>       3. `asPath` - 显示在浏览器中的实际路径（包含查询部分），为`String`类型
>       4. `req` - HTTP 请求对象 (只有服务器端有)
>       5. `res` - HTTP 返回对象 (只有服务器端有)
>       6. `jsonPageRes` - [获取数据响应对象](https://github.com/zeit/next.js/tree/7.0.0-canary.8/examples/with-aphrodite) (只有客户端有)
>       7. `err` - 渲染过程中的任何错误
> 4. 加样式

### 1.布局

```jsx
import Repo from '../../components/Repo'
import Link from 'next/link'
import api from '../../lib/api'

const Detail = ({ repoBasic }) => {
  console.log(repoBasic)
  return (
    <div className="root">
      <div className="repo-basic">
        <Repo repo={ repoBasic }/>
        <div className="tabs">
          <Link href="/detail">
            <a className="tab index">Readme</a>
          </Link>
          <Link href="/detail/issues">
            <a className="tab issues">issues</a>
          </Link>
        </div>
      </div>
      <div>Readme</div>
      <style jsx>
        {`
          .root {
            padding-top: 20px;
          }
          .repo-basic {
            padding: 20px;
            border: 1px solid #eee;
            margin-bottom: 20px;
            border-radius: 5px;
          }
          .tab + .tab {
            margin-left: 20px;
          }
        `}
      </style>
    </div>
  )
}
Detail.getInitialProps = async ({ router, ctx }) => {
  const { owner, name } = ctx.query
  // github api: GET /repos/:owner/:repo
  const repoBasic = await api.request({
    url: `/repos/${owner}/${name}`
  }, ctx.req, ctx.res)
  return {
    repoBasic
  }
}

export default Detail
```

>  报错: GET http://localhost:3000/github/repos/undefined/undefined 500 (Internal Server Error)
>
> 如果查看console.log(router), 会显示
>
> Router {route: "/detail", components: {…}, events: {…}, pageLoader: PageLoader, onPopState: ƒ, …}
>
> 这是因为nextjs中, 在getInitialProps中router获取的query是老的信息, 需要使用ctx.query才能获取url中的参数



- 问题: 当我们点击readme或者issues是无法直接带上url: http://localhost:3000/detail?owner=beyondme121&name=appVueFrontEnd中的参数信息的owner=beyondme121&name=appVueFrontEnd

  无法带上参数，也就无法获取仓库的详情!!

  

![detail详情点击带上参数](C:\projects\react-projects\github-next\images\detail详情点击带上参数.png)





创建一个方法

```js
// 入参: 因为从路由拿到的是query对象,key-value对儿
function makeQuery (queryObject) {
  const query = Object.entries(queryObject).reduce((result, entry) => {
    result.push(entry.join('='))
    return result // 别忘了result
  }, []).join('&')
  return `?${query}`
}
```



```jsx
import { withRouter } from 'next/router'

function Detail ({ repoBasic, router }) {
    const query = makeQuery(router.query)
    // ....
    return (
    	// .. 链接拼接上仓库查询需要的参数,参数来自url, 从router中获取, 是通过点击某个仓库,进入/detail?owner=beyondme121&name=backend-nextjs-react中获取的, 然后再点击readme把url中的参数加上去
        <Link href={`/detail${query}`}>
            <a className="tab index">Readme</a>
        </Link>
    )
    
}

export default withRouter(Detail)
```



## style-jsx

这种方式引入的样式在不同组件之间不会相互影响，甚至父子组件之间都不会相互影响

## 避坑

1. 配置文件一定要重启, 即使使用了nodemon, 也要重启

```js
module.exports = withCSS({
  env: {
    customerKey: 'A0001',     // 页面使用process.env.customerKey获取
  },
  publicRuntimeConfig: {
    customerKey: 'A0002'
  }
})
```



## github认证

### 配置文件保存github oauth


